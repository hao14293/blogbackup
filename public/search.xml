<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas-nest.js]]></title>
    <url>%2Fyear%2F04%2F17%2F53322%2F</url>
    <content type="text"><![CDATA[可能大家会看到很多像我博客背景中有网状物的东西在漂浮，感觉很好玩，我第一次见得时候也是感觉特别有意思。今天就来说一下，当然这个炫酷的东西不是我写的，项目地址.如果你想在你网站中使用，可以直接在&lt;/body&gt;前加上1&lt;script src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"&gt;&lt;/script&gt; 就可以了。源码这里也搬运一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * Copyright (c) 2016 hustcc * License: MIT * Version: v1.0.1 * GitHub: https://github.com/hustcc/canvas-nest.js**/! function() &#123; //封装方法，压缩之后减少文件大小 function get_attribute(node, attr, default_value) &#123; return node.getAttribute(attr) || default_value; &#125; //封装方法，压缩之后减少文件大小 function get_by_tagname(name) &#123; return document.getElementsByTagName(name); &#125; //获取配置参数 function get_config_option() &#123; var scripts = get_by_tagname("script"), script_len = scripts.length, script = scripts[script_len - 1]; //当前加载的script return &#123; l: script_len, //长度，用于生成id用 z: get_attribute(script, "zIndex", -1), //z-index o: get_attribute(script, "opacity", 0.5), //opacity c: get_attribute(script, "color", "0,0,0"), //color n: get_attribute(script, "count", 99) //count &#125;; &#125; //设置canvas的高宽 function set_canvas_size() &#123; canvas_width = the_canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, canvas_height = the_canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; &#125; //绘制过程 function draw_canvas() &#123; context.clearRect(0, 0, canvas_width, canvas_height); //随机的线条和当前位置联合数组 var e, i, d, x_dist, y_dist, dist; //临时节点 //遍历处理每一个点 random_points.forEach(function(r, idx) &#123; r.x += r.xa, r.y += r.ya, //移动 r.xa *= r.x &gt; canvas_width || r.x &lt; 0 ? -1 : 1, r.ya *= r.y &gt; canvas_height || r.y &lt; 0 ? -1 : 1, //碰到边界，反向反弹 context.fillRect(r.x - 0.5, r.y - 0.5, 1, 1); //绘制一个宽高为1的点 //从下一个点开始 for (i = idx + 1; i &lt; all_array.length; i++) &#123; e = all_array[i]; // 当前点存在 if (null !== e.x &amp;&amp; null !== e.y) &#123; x_dist = r.x - e.x; //x轴距离 l y_dist = r.y - e.y; //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist; //总距离, m dist &lt; e.max &amp;&amp; (e === current_point &amp;&amp; dist &gt;= e.max / 2 &amp;&amp; (r.x -= 0.03 * x_dist, r.y -= 0.03 * y_dist), //靠近的时候加速 d = (e.max - dist) / e.max, context.beginPath(), context.lineWidth = d / 2, context.strokeStyle = "rgba(" + config.c + "," + (d + 0.2) + ")", context.moveTo(r.x, r.y), context.lineTo(e.x, e.y), context.stroke()); &#125; &#125; &#125;), frame_func(draw_canvas); &#125; //创建画布，并添加到body中 var the_canvas = document.createElement("canvas"), //画布 config = get_config_option(), //配置 canvas_id = "c_n" + config.l, //canvas id context = the_canvas.getContext("2d"), canvas_width, canvas_height, frame_func = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(func) &#123; window.setTimeout(func, 1000 / 45); &#125;, random = Math.random, current_point = &#123; x: null, //当前鼠标x y: null, //当前鼠标y max: 20000 // 圈半径的平方 &#125;, all_array; the_canvas.id = canvas_id; the_canvas.style.cssText = "position:fixed;top:0;left:0;z-index:" + config.z + ";opacity:" + config.o; get_by_tagname("body")[0].appendChild(the_canvas); //初始化画布大小 set_canvas_size(); window.onresize = set_canvas_size; //当时鼠标位置存储，离开的时候，释放当前位置信息 window.onmousemove = function(e) &#123; e = e || window.event; current_point.x = e.clientX; current_point.y = e.clientY; &#125;, window.onmouseout = function() &#123; current_point.x = null; current_point.y = null; &#125;; //随机生成config.n条线位置信息 for (var random_points = [], i = 0; config.n &gt; i; i++) &#123; var x = random() * canvas_width, //随机位置 y = random() * canvas_height, xa = 2 * random() - 1, //随机运动方向 ya = 2 * random() - 1; // 随机点 random_points.push(&#123; x: x, y: y, xa: xa, ya: ya, max: 6000 //沾附距离 &#125;); &#125; all_array = random_points.concat([current_point]); //0.1秒后绘制 setTimeout(function() &#123; draw_canvas(); &#125;, 100);&#125;(); 不得不多，css3和html5是越来越强大了，可以实现很多之前只能用js实现的效果，而且js也是越来越强大，所以前端还是很有前途的。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS总结(持续更新)]]></title>
    <url>%2Fyear%2F04%2F17%2F31424%2F</url>
    <content type="text"><![CDATA[CSS属性繁多，有些属性用的时候总想不起来，所以就写个记录贴，这样便于记忆和复习。 阴影（shadow)shadow有text-shadow(文本阴影)和box-shadow(框阴影)两种.语法12text-shadow: h-shadow v-shadow blur color;box-shadow: h-shadow v-shadow blur spread color inset; 通过设置shadow属性可以实现很多效果，比如我将导航栏设置为鼠标移动到上面时多出来6px不同颜色的高度。代码如下：12345678910a:link &#123; display: inline-block; height: 90%; width: 18%; position: relative; background-color: #DAD9CC;&#125;a: hover &#123; box-shadow: 0px -8px 0px # 858471;&#125; background: transparent经常会看到这样的代码123* &#123; background: transparent;&#125; 意思就是背景透明。实际上background默认的颜色就是透明的属性，所以写和不写都是一样的。但如果一个元素覆盖在另一个元素之上，而你想显示下面的元素，这时你就需要把上面的这个元素设置为background: transparent;. z-index首先声明： z-index 仅能在定位元素上奏效，即只能在position属性值为relative、absolute或fixed的元素上有效。基本原理是：z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。元素可拥有负的 z-index 属性值。 width: auto 和 width: 100% 区别12345678910width: auto* 子元素（包括content+padding+border+margin）撑满整个父元素的content区域。* 子元素有margin、border、padding时，会减去子元素content区域相对应的width值* 父元素的content = 子元素（content + padding + border + margin )width: 100%* 强制将子元素的content区域 撑满 父元素的content区域* 子元素有margin、border、padding时，不改变子元素content区域的width，而是溢出父盒子，保持原有值* 父元素的content = 子元素的content 来看个例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; margin: 0;padding: 0; &#125; body &#123; background: #dcdcdc; &#125; .box &#123; width: 400px; border: 3px solid red; padding: 0 50px; &#125; .box1 &#123; width: auto; height: 100px; background: pink; padding: 0 50px; margin: 0 50px; border-width: 0 50px; border-style: solid; border-color: green; &#125; .box2 &#123; width: 100%; height: 100px; background: gold; padding: 0 50px; margin: 0 50px; border-width: 0 50px; border-style: solid; border-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text-transformtext-transform 属性控制文本的大小写。 值 描述 none 默认。定义带有小写字母和大写字母的标准的文本. capitalize 文本中的每个单词以大写字母开头。 uppercase 定义仅有大写字母。 lowercase 定义无大写字母，仅有小写字母。 inherit 规定应该从父元素继承 text-transform 属性的值。 background-size语法:1background-size: length|percentage|cover|contain; 值 描述 length 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。 percentage 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。 cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 opacityopacity 属性设置元素的不透明级别。12语法opacity: value|inherit; 值 描述 value 规定不透明度。从 0.0 （完全透明）到 1.0（完全不透明）。 inherit 应该从父元素继承 opacity 属性的值。 &lt;video&gt;属性 属性 值 描述 autoplay autoplay 如果出现该属性，则视频在就绪后马上播放。 controls controls 如果出现该属性，则向用户显示控件，比如播放按钮。 height pixels 设置视频播放器的高度。 loop loop 如果出现该属性，则当媒介文件完成播放后再次开始播放。 muted muted 规定视频的音频输出应该被静音。 poster URL 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像. preload preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 src url 要播放的视频的 URL。 width pixels 设置视频播放器的宽度。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将视频作为页面背景的问题]]></title>
    <url>%2Fyear%2F04%2F16%2F3879%2F</url>
    <content type="text"><![CDATA[使用视频作为网页背景是件很酷的事情，但也是件困难的事情。CSS里的background-image属性只能使用图片、SVG、颜色或渐变色。但从技术讲，我们是可以伪造出一种效果，让视频以背景的角色出现在其它HTML元素后面。这其中的难点是视频要填充整个浏览器页面，而且要响应浏览器窗口大小的变化。 观看演示1 视频作为网页背景的限制因素在动手编码实现前，视频作为网页背景的有些问题我们要先考虑清楚： 并不是因为技术上可行你就可以任意使用：作为背景的视频内容必须能增强页面内容的感染力，而不是因为漂亮或技术上很酷就使用它。 作为背景的视频应该设置为自动播放，而默认状态下应该是关闭声音；事实上，视频里面最好不含声音。(你可以在页面上放置一个控制声音的按钮。) 背景视频应该有个替代图片，当浏览器不支持这种HTML5技术、视频格式时用图片替代。在等待背景视频加载的过程中也应该使用背景图片占位。而对于一些手机移动设备不支持视频自动播放，也应该使用图片替代。 视频长度很重要：太短了会明显感到重复播放(背景视频通常情况是重复播放的)，太长就变成了情节叙事，如果这样，这段视频应该单独放到页面上播放。我建议视频的长度应该是12-30秒之间。 带宽是个大问题。视频的体积应很小，尽量的压缩。同时，它需要在不同尺寸设备上自动的适应屏幕大小。如果有可能，应该使用JavaScript控制对不同的屏幕大小加载不同分辨率的背景视频。背景视频最好小于5M，如果你小于500K，那是更好。 对上面说的这些情况心里要有数，下面我们来看看技术实现上的细节。 CSS代码使用HTML5里播放视频的代码方法视频：1234567&lt;video autoplay loop poster="polina.jpg" id="bgvid"&gt; &lt;source src="polina.webm" type="video/webm"&gt; &lt;source src="polina.mp4" type="video/mp4"&gt;&lt;/video&gt; 注意：这里摆放视频格式的顺序很重要，因为有些版本的谷歌浏览器里，如果.webm格式的视频放在了其他视频后面，视频将无法播放。 我们使用视频的第一帧图像作为视频的封面图片，这样，当背景视频一旦加载完成，我们可以看到很流畅的从图片过度到背景视频播放。 让视频扩展到全屏的方法：12345678910111213video#bgvid &#123; position: fixed; right: 0; bottom: 0; min-width: 100%; min-height: 100%; width: auto; height: auto; z-index: -100; background: url(polina.jpg) no-repeat; background-size: cover; &#125; 一些老式的浏览器无法播放这种格式的视频，但它们仍然识别&lt;video&gt;标记(除了IE8/6)。对于这些浏览器，我们使用了background-image来弥补它们的不支持，使用的图片就是视频的封面图片。 你可能会发现，在手机设备上，&lt;video&gt;标记是无法扩展到全屏的，因为这些设备的屏幕长宽比限制了视频的扩展。我在以后的文章里了会继续探讨这个问题。 视频背景技术在 IE 8 上的问题IE8不仅不能识别&lt;video&gt;标记，它对所有的HTML5标记都不能识别，这是一个问题，对于IE8，我们至少要让替代的背景图片能显示出来。为了达到这个目的，我们需要两件事情：一行JavaScript代码，一个CSS条件判断注释语句。123456789&lt;!--[if lt IE 9]&gt;&lt;script&gt; document.createElement('video');&lt;/script&gt;&lt;![endif]--&gt; 在你的CSS代码里做如下的声明，让IE知道&lt;video&gt;是一个block元素：1video &#123; display: block; &#125; 有了这句代码，IE8至少能识别&lt;video&gt;标记，可以正确的显示背景图片。 使用JavaScript实现视频背景尽管使用HTML5/CSS3实现视频背景要比使用JavaScript好一些，但不妨说一下，有一些jQuery插件和JavaScript工具包也能达到视频背景的效果。下面是几个演示： 观看演示2 &nbsp;&nbsp;观看演示3 结论如果一个网站上使用了视频背景，那会变得相当的酷，但是，“能力越大，责任越大”，请审慎明智的使用。 (英文：Create Fullscreen HTML5 Page Background Video.)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS里的line-height详解]]></title>
    <url>%2Fyear%2F04%2F15%2F31791%2F</url>
    <content type="text"><![CDATA[一、前言最近写CSS一直会用到line-height属性，但对其一直是一知半解。在看完《CSS权威指南》后，这周末就写写line-height的相关内容。 二、 基线、行间距和行高先说清楚一些名词概念，这是理解下文的基础,首先看一张图: 基线: 一个文本行分成4格线，分别是顶线、中线、基线、底线， 1基线的位置与 字体font-family 有关，不同的字体基线的位置有偏差 内容区（content area）: 顶线与底线包围的区域,其高度与字体和字号相关, 1粗略等于 font-size值; 行间距: 文本行基线之间的距离,由 line-height-font-size决定;还是看上面那张图，就有比较直观的感受了。下面是重点！注意看， line-height= (基线-底线的距离)+行距+(顶线-基线的距离)，等价于 顶线-基线+基线-底线 + 行距 = 顶线-底线 + 行距 而根据上文的定义， 顶线-底线就是内容区的大小，它由 font-size属性决定;所以可以得出: line-height= font-size + 行距 换句话说， 行间距=line-height - font-size 行内框/行高: 它就是单个内联元素的高度！它是由 line-height属性决定的;123我们在内容区的上下两部分，各自加上半行间距(行间距的一半)，就是行内框的高度；所以，行内框的大小就是: `（line-height - font-size)/2+font-size + （line-height - font-size)/2`即`（line-height - font-size) + font-size= line-height` 一定要注意:1仅考虑文本的情况，行内（文本）元素的高度是由line-height决定的，并不是由元素中的文本撑开的 行框: 它就是一行中，有多个内联元素时的 总体高度1由该行中行内框组成, 行框高度要包含最高行内框的顶端和最低行内框的底端 下面这张图，很直观的反应了行内框和行框的概念(但他内容区的): 所以总结一下就是，我们可以简单理解为， font-size :可以控制 内联元素里 文本大小(当然也和font-fmaily有关); line-height:可以控制 内联元素的 文本高度; 三、 line-height属性的值 em/ex和百分数值: 都相对于 (父)元素的font-size值 计算； number: 继承的是一个缩放因子，子元素能够根据自己的字体大小计算行高; 四、图像的行内框1图像元素的行内框高度是由它自己的盒子（height+padding+border+margin）决定的 五、参考文档 1. css中的line-height; 2. CSS line-height与行内框;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CSS布局]]></title>
    <url>%2Fyear%2F04%2F12%2F7925%2F</url>
    <content type="text"><![CDATA[没有布局如果你只想把所有内容都塞进一栏里，那么不用设置任何布局也是OK的。然而，如果用户把浏览器窗口调整的很大，这时阅读网页会非常难受：读完每一行之后，你的视觉焦点要从右到左移动一大段距离。试着调整下浏览器窗口大小你就明白我的意思了！ 在解决这个问题之前，我们需要了解一个很重要的属性： display. display属性display 是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值，这与元素的类型有关。对于大多数元素它们的默认值通常是 block 或 inline 。一个 block 元素通常被叫做块级元素。一个 inline 元素通常被叫做行内元素。 block div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p 、 form 和HTML5中的新元素： header 、 footer 、 section 等等。 inlinespan是一个标准的行内元素。一个行内元素可以在段落中像这样包裹一些文字而不会打乱段落的布局。a元素是最常用的行内元素，它可以被用作链接。 none另一个常用的display值是none。一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。 它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden; 还会占据空间。 其他display值还有很多的更有意思的 display 值，例如 list-item 和 table 。这里有一份详细的列表。之后我们会讨论到 inline-block 和 flex 。 额外加分点就像我之前讨论过的，每个元素都有一个默认的 display 类型。不过你可以随时随地的重写它！虽然“人为制造”一个行内元素可能看起来很难以理解，不过你可以把有特定语义的元素改成行内元素。常见的例子是：把 li 元素修改成 inline，制作成水平菜单。 margin:auto;1234#main &#123; width: 600px; margin: 0 auto;&#125; 设置块级元素的 width 可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为 auto 来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进下这个方案… max-width1234#main &#123; max-width: 600px; margin: 0 auto;&#125; 在这种情况下使用 max-width 替代 width 可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要，调整下浏览器窗口大小检查下吧！ 顺便提下， 所有的主流浏览器包括IE7+在内都支持 max-width ，所以放心大胆的用吧。 盒模型在我们讨论宽度的时候，我们应该讲下与它相关的另外一个重点知识：盒模型。当你设置了元素的宽度，实际展现的元素却超出你的设置：这是因为元素的边框和内边距会撑开元素。看下面的例子，两个相同的元素显示的实际宽度却不一样。12345678910.simple&#123; width: 500px; margin: 20px auto;&#125;.fancy&#123; width: 500px; margin: 20px auto; padding: 50px; border-width: 10px;&#125; 以前有一个代代相传的解决方案是通过数学计算。CSS开发者需要用比他们实际想要的宽度小一点的宽度，需要减去内边距和边框的宽度。值得庆幸地是你不需要再这么做了… box-sizing人们慢慢的意识到传统盒子模型不直接，所以它们新增了一个叫做box-sizing的CSS属性。当你设置了一个元素为box-sizing: border-box;时，此元素的内边距和边框不再增加他的宽度。这里由一个与前一页相同的例子，惟一的区别是两个元素都设置了box-sizing: border-box;:12345678910111213141516.simple &#123; width: 500xp; margin: 20px auto; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; .fancy &#123; width: 500px; margin: 20px auto; padding: 50px; border: solid blue 10px; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; 既然没有比这更好的方法，一些CSS开发者想要页面上所有的元素都有如此表现。所以开发者们把以下CSS代码放在它们页面上： 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; 这样可以确保所有的元素都会用这种更直观的方式排版。&lt;br&gt; 不过&lt;code&gt;box-sizing&lt;/code&gt;是个很新的属性，目前你还应该向我上面例子中那样使用&lt;code&gt;-webkit&lt;/code&gt;和&lt;code&gt;-moz-&lt;/code&gt;前缀。这可以启动特定浏览器实验中的特性。同时记住它是支持IE8+的。 position为了制作更多复杂的布局，我们需要讨论下position属性。它有一大堆的值，名字还都特抽象，别提有多难记了。让我们先一个个的过一遍，不过你最好还是把这页放到书签里。 static123.static &#123; position: static;&#125; relative12345678910.relative1 &#123; position: relative;&#125;.relative2 &#123; position: relative; top: -20px; left: 20px; background-color: white; width: 500px;&#125; fixed一个固定定位（position属性的值为fixed)元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和 relative 一样， top 、 right 、 bottom 和 left 属性都可用。 比如让一个div始终显示在页面右下角，CSS如下：1234567.fixed &#123; position: fixed; bottom: 0; right: 0; width: 200px; background-color: white;&#125; 一个固定定位元素不会保留它原本在页面应有的空隙（脱离文档流）。令人惊讶地是移动浏览器对 fixed 的支持很差。这里有相应的解决方案. absoluteabsolute是最棘手的position值。 absolute 与 fixed 的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 position 值不是 static 的元素。 position例子通过具体的例子可以帮助我们更好地理解”position”。下面是一个真正的页面布局。1234567891011121314151617181920212223.container &#123; position: relative;&#125;nav &#123; position: absolute; left: 0px; width: 200px;&#125;section &#123; /* position is static by default */ amrgin-left: 200px;&#125;footer &#123; position: fixed; bottom: 0; left: 0; height: 70px; background-color: white; width: 100%;&#125;body &#123; margin-bottom: 120px;&#125; 这个例子在容器比nav元素高的时候可以正常工作。如果容器比nav元素低，那么nav会溢出到容器的外面。之后我们会讨论下其他布局技术，它们都各有优劣。 float另一个布局中常用的CSS属性是float。float可用于实现文字环绕图片，如下1234img &#123; float: right; margin: 0 0 1em 1em;&#125; clearclear属性被用于控制浮动。比较下面两个例子：12&lt;div class="box"&gt;...&lt;/div&gt;&lt;section&gt;...&lt;/section&gt; 123456.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125; 123456789.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125;.after-box &#123; clear: left;&#125; 清除浮动(clearfix hack)在使用浮动的时候经常会遇到一个古怪的事情：123img &#123; float: right;&#125; 见证奇迹的时刻到了！有一种比较丑陋的方法可以解决这个问题，它叫做清除浮动（clearfix hack）. 让我们加入一些新的CSS样式：123.clearfix &#123; overflow: auto;&#125; 现在再看看发生了什么：这个可以在现代浏览器上工作。如果你想要支持IE6，你就需要再加入如下样式：1234.clearfix &#123; overflow: auto; zoom: 1;&#125; 有些独特的浏览器需要“额外的关照”。清除浮动这潭 水很深很深，但是这个简单的解决方案已经可以在今天所有的主要浏览器上工作。 浮动布局例子完全使用 float 来实现页面的布局是很常见的。这里有一个我之前用 position 实现的布局例子，这次我使用 float 实现了它。1234567nav &#123; float: left; width: 200px;&#125;section &#123; margin-left: 200px;&#125; 媒体查询“响应式设计（Responsive Design” 是一种让网站针对不同的浏览器和设备“呈现”不同显示效果的策略，这样可以让网站在任何情况下显示的很棒！ 媒体查询是做此事所需的最强大的工具。让我们使用百分比宽度来布局，然后在浏览器变窄到无法容纳侧边栏中的菜单时，把布局显示成一列：1234567891011121314@media screen and (min-width: 600px)&#123; nav &#123; float: left; width: 25%; &#125; section &#123; margin-left: 25%; &#125;&#125;@media screen and (max-width: 599px)&#123; nav li&#123; display: inline; &#125;&#125; 使用 meta viewport 之后可以让你的布局在移动浏览器上显示的更好。 inline-block你可以创建很多网格来铺满浏览器。在过去很长的一段时间内使用 float 是一种选择，但是使用 inline-block 会更简单。让我们看下使用这两种方法的例子： 困难的方式（使用浮动）123456789.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125;.after-box &#123; clear: left;&#125; 容易的方式（使用 inline-block）你可以用 display 属性的值 inline-block 来实现相同效果。123456.box2 &#123; display: inline-block; width: 200px; height: 100px; margin: 1em;&#125; inline-block布局你可以使用 inline-block 来布局。有一些事情需要你牢记： vertical-align 属性会影响到 inline-block 元素，你可能会把它的值设置为 top 。 你需要设置每一列的宽度 如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙 123456789nav &#123; display: inline-block; vertical-align: top; width: 25%;&#125;.column &#123; display: inline-block; vertical-align: top; width: 75%;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞懂 JS 中 this 机制]]></title>
    <url>%2Fyear%2F04%2F10%2F64598%2F</url>
    <content type="text"><![CDATA[目录 this 是什么 this 的四种绑定规则 绑定规则的优先级 绑定例外 扩展：箭头函数 this 是什么 理解this之前， 先纠正一个观点，this 既不指向函数自身，也不指函数的词法作用域。如果仅通过this的英文解释，太容易产生误导了。它实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。 this 的四种绑定规则 this的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。 默认绑定什么叫默认绑定，即没有其他绑定规则存在时的默认规则。这也是函数调用中最常用的规则。 来看这段代码：123456function foo() &#123; &#125; console.log( this.a );var a = 2; foo(); //打印的是什么？foo() 打印的结果是2。 因为foo()是直接调用的（独立函数调用），没有应用其他的绑定规则，这里进行了默认绑定，将全局对象绑定this上，所以this.a 就解析成了全局变量中的a，即2。 注意：在严格模式下（strict mode），全局对象将无法使用默认绑定，即执行会报undefined的错误1234567function foo() &#123; "use strict"; console.log( this.a );&#125;var a = 2; foo(); // Uncaught TypeError: Cannot read property 'a' of undefined 隐式绑定除了直接对函数进行调用外，有些情况是，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。123456789101112function foo() &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;obj.foo(); // ? obj.foo() 打印的结果是3。 这里foo函数被当做引用属性，被添加到obj对象上。这里的调用过程是这样的： 获取obj.foo属性 -&gt; 根据引用关系找到foo函数，执行调用 所以这里对foo的调用存在上下文对象obj，this进行了隐式绑定，即this绑定到了obj上，所以this.a被解析成了obj.a，即3。 多层调用链1234567891011121314151617function foo() &#123; console.log( this.a );&#125;var a = 2;var obj1 = &#123; a: 4, foo: foo &#125;;var obj2 = &#123; a: 3, obj1: obj1&#125;;obj2.obj1.foo(); //? obj2.obj1.foo() 打印的结果是4。同样，我们看下函数的调用过程： 先获取obj1.obj2 -&gt; 通过引用获取到obj2对象，再访问 obj2.foo -&gt; 最后执行foo函数调用 这里调用链不只一层，存在obj1、obj2两个对象，那么隐式绑定具体会绑哪个对象。这里原则是获取最后一层调用的上下文对象，即obj2，所以结果显然是4（obj2.a）。 隐式丢失（函数别名）注意：这里存在一个陷阱，大家在分析调用过程时，要特别小心 先看个代码：12345678910111213function foo() &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo;bar(); //? bar() 打印的结果是2。 为什么会这样，obj.foo 赋值给bar，那调用bar()为什么没有触发隐式绑定，使用的是默认绑定呢。 这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。 那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定，全局属性a。 隐式丢失（回调函数）123456789101112function foo() &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;setTimeout( obj.foo, 100 ); // ？ 打印的结果是2。 同样的道理，虽然参传是obj.foo，因为是引用关系，所以传参实际上传的就是foo对象本身的引用。对于setTimeout的调用，还是 setTimeout -&gt; 获取参数中foo的引用参数 -&gt; 执行 foo 函数，中间没有obj的参与。这里依旧进行的是默认绑定。 显示绑定相对隐式绑定，this值在调用过程中会动态变化，可是我们就想绑定指定的对象，这时就用到了显示绑定。 显示绑定主要是通过改变对象的prototype关联对象，这里不展开讲。具体使用上，可以通过这两个方法call(…)或apply(…)来实现（大多数函数及自己创建的函数默认都提供这两个方法）。 call与apply是同样的作用，区别只是其他参数的设置上123456789101112131415function foo() &#123; console.log( this.a );&#125;var a = 2;var obj1 = &#123; a: 3,&#125;;var obj2 = &#123; a: 4,&#125;;foo.call( obj1 ); // ?foo.call( obj2 ); // ? 打印的结果是3, 4。 这里因为显示的申明了要绑定的对象，所以this就被绑定到了obj上，打印的结果自然就是obj1.a 和obj2.a。 硬绑定12345678910111213141516171819202122function foo() &#123; console.log( this.a );&#125;var a = 2;var obj1 = &#123; a: 3,&#125;;var obj2 = &#123; a: 4,&#125;;var bar = function()&#123; foo.call( obj1 );&#125;bar(); // 3setTimeout( bar, 100 ); // 3bar.call( obj2 ); // 这是多少 前面两个（函数别名、回调函数）打印3，因为显示绑定了，没什么问题。 最后一个打印是3。 这里需要注意下，虽然bar被显示绑定到obj2上，对于bar，function(){…} 中的this确实被绑定到了obj2，而foo因为通过foo.call( obj1 )已经显示绑定了obj1，所以在foo函数内，this指向的是obj1，不会因为bar函数内指向obj2而改变自身。所以打印的是obj1.a（即3）。 new 绑定js中的new操作符，和其他语言中（如JAVA）的new机制是不一样的。js中，它就是一个普通函数调用，只是被new修饰了而已。 使用new来调用函数，会自动执行如下操作： 如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。从第三点可以看出，this指向的就是对象本身。 看个代码：1234567891011function foo(a) &#123; this.a = a;&#125;var a = 2;var bar1 = new foo(3);console.log(bar1.a); // ?var bar2 = new foo(4);console.log(bar2.a); // ? 最后一个打印是3, 4。 因为每次调用生成的是全新的对象，该对象又会自动绑定到this上，所以答案显而易见。 绑定规则优先级 上面也说过，这里在重复一下。优先级是这样的，以按照下面的顺序来进行判断: 数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话,this绑定的是 指定的对象。 数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象。 果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。 var bar = foo() 规则例外 在显示绑定中，对于null和undefined的绑定将不会生效。 代码如下：12345function foo() &#123; console.log( this.a );&#125;foo.call( null ); // 2foo.call( undefined ); // 2 这种情况主要是用在不关心this的具体绑定对象（用来忽略this），而传入null实际上会进行默认绑定，导致函数中可能会使用到全局变量，与预期不符。 所以对于要忽略this的情况，可以传入一个空对象ø，该对象通过Object.create(null)创建。这里不用{}的原因是，ø是真正意义上的空对象，它不创建Object.prototype委托，{}和普通对象一样，有原型链委托关系。 1. 这里传null的一种具体使用场景是函数柯里化的使用 扩展：箭头函数 最后，介绍一下ES6中的箭头函数。通过“=&gt;”而不是function创建的函数，叫做箭头函数。它的this绑定取决于外层（函数或全局）作用域。 case 1 (正常调用) 普通函数 123456789101112function foo()&#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;obj.foo(); //3 箭头函数 12345678910111213var foo = () =&gt; &#123; console.log( this.a );&#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;obj.foo(); //2foo.call(obj); //2 ，箭头函数中显示绑定不会生效 case 2 （函数回调） 普通函数 123456789101112131415function foo()&#123; return function()&#123; console.log( this.a ); &#125; &#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo();bar(); //2 箭头函数 1234567891011121314151617function foo()&#123; return () =&gt; &#123; console.log( this.a ); &#125; &#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo();bar(); //3 通过上面两个列子，我们看到箭头函数的this绑定只取决于外层（函数或全局）的作用域，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。 注意：对于ES6之前，箭头函数的替换版本是这样的12345678910111213141516// es6function foo()&#123; return () =&gt; &#123; console.log( this.a ); &#125; &#125;var a = 2;var obj = &#123; a: 3, foo: foo &#125;;var bar = obj.foo();bar(); //3 通过上面两个列子，我们看到箭头函数的this绑定只取决于外层（函数或全局）的作用域，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。 注意：对于ES6之前，箭头函数的替换版本是这样的1234567891011121314// es6function foo()&#123; return () =&gt; &#123; console.log( this.a ); &#125; &#125;// es6之前的替代方法function foo()&#123; var self = this; return () =&gt; &#123; console.log( self.a ); &#125; &#125; 总结 我们在使用js的过程中，对于this的理解往往觉得比较困难，再调试过程中有时也会出现一些不符合预期的现象。很多时候，我们都是通过一些变通的方式（如：使用具体对象替换this）来规避的问题。可问题一直存在那儿，我们没有真正的去理解和解决它。 本文主要参考了《你不知道的JavaScript（上卷）》，对this到底是什么，具体怎么绑定的，有什么例外情况以及ES6中的一个优化方向，来彻底搞清楚我们一直使用的this到底是怎么玩的。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生需要诗意]]></title>
    <url>%2Fyear%2F04%2F06%2F22604%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周周周杰伦]]></title>
    <url>%2Fyear%2F04%2F01%2F65184%2F</url>
    <content type="text"><![CDATA[网易云下架我伦真是在作死，不过估计这也是鹅厂为了打压网易云采取的卑劣手法吧。不能在云村听我伦真是难受，可是又实在不想用QQ音乐。唉，真是难受啊。不过网易云近来好像有点飘了。大家喜欢用网易云不外乎简洁的界面、贴心的日推和那些段子评论吧。可更新到5.0后，界面不再简洁，为了追短视频的热潮，把网易云硬是变成了网易快手、网易小视频，这应该违背了网易云音乐的初心了吧。本来在版权上就没什么优势，如果只是靠着情怀来拉拢用户，那估计用户也会慢慢流失吧。这次被迫下架杰伦事件希望可以给网易云提个醒，勿忘初心，还是简简单单做回最初的网易云音乐吧，做回大家熟悉的网易云吧。 杰伦所有的歌曲我网盘里整理的有，下载到本地就能继续用网易云听杰伦了。 链接: https://pan.baidu.com/s/1XT711VsLCOMq4FckZgx4dg 密码: anbd]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[知道这20个正则表达式，能让你少写1,000行代码]]></title>
    <url>%2Fyear%2F03%2F25%2F55931%2F</url>
    <content type="text"><![CDATA[正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：123var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; var r = fieldValue.match(reg); if(r==null)alert('Date format error!'); 下面是在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。1^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 2. 校验中文字符串仅能是中文。1^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 3. 由数字、26个英文字母或下划线组成的字符串1^\\w+$ 4. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。1[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 5. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位：1^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$ 18位：1^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$ 6. 校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。1^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额金额校验，精确到2位小数。1^[0-9]+(.[0-9]&#123;2&#125;)?$ 8. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）1^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 9. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。1^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$ 10. 校验IP-v4地址IP4 正则语句。1\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b 11. 校验IP-v6地址IP6 正则语句。1(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])) 12. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。1234if (!s.match(/^[a-zA-Z]+:\\/\\//))&#123; s = 'http://' + s;&#125; 13. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。1^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)? 14. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件）1^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"&lt;&gt;|]+\\.txt(l)?$ 15. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。1^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$ 16. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。1\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\"\\']&#123;0,1&#125;([^\\"\\'\\ &gt;]*) 17. 提取页面超链接提取html中的超链接。1(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^"]+)"((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; 18. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。1^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125; 19. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。1&lt;!--(.*?)--&gt; 20. 匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。1&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:".*?"|'.*?'|[\\^'"&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime_Text_3快捷键]]></title>
    <url>%2Fyear%2F03%2F20%2F31863%2F</url>
    <content type="text"><![CDATA[Sublime Text 3 快捷键精华版Ctrl+Shift+P：打开命令面板Ctrl+P：搜索项目中的文件Ctrl+G：跳转到第几行Ctrl+W：关闭当前打开文件Ctrl+Shift+W：关闭所有打开文件Ctrl+Shift+V：粘贴并格式化Ctrl+D：选择单词，重复可增加选择下一个相同的单词Ctrl+L：选择行，重复可依次增加选择下一行Ctrl+Shift+L：选择多行Ctrl+Shift+Enter：在当前行前插入新行Ctrl+X：删除当前行Ctrl+M：跳转到对应括号Ctrl+U：软撤销，撤销光标位置Ctrl+J：选择标签内容Ctrl+F：查找内容Ctrl+Shift+F：查找并替换Ctrl+H：替换Ctrl+R：前往 methodCtrl+N：新建窗口Ctrl+K+B：开关侧栏Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身Ctrl+F2：设置/删除标记Ctrl+/：注释当前行Ctrl+Shift+/：当前位置插入注释Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的Ctrl+Shift+A：选择当前标签前后，修改标签用的F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Alt+.：闭合标签Alt+Shift+数字：分屏显示Alt+数字：切换打开第N个文件Shift+右键拖动：光标多不，用来更改或插入列内容鼠标的前进后退键可切换Tab文件按Ctrl，依次点击或选取，可需要编辑的多个位置按Ctrl+Shift+上下键，可替换行 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 配置编译环境控制台输入（以C++为例） 原理很简单，就是在外部建立一个用来执行文件的 bat，然后调用它。注意的就是，需要用start 来打开一个新窗口，同时需要 pause 一下来看结果，其中很蛋疼的就是Sublime默认后台执行你的start，如果你的pause和start放在一个文件了pause对start %1 的文件是无效的，因此其实需要建立两个文件。注意环境变量。。。（关于什么是环境变量，三两句解释不清楚，最好自己百度一下。） 配好之后个人感觉控制台输入意义不是很大，做题的话都是从文件读入，做开发基本不需要读入。So~ 各位慎重。123456789101112131415161718MyCRun.bat@echo off %1 echo. echo ------------------- pause exit MyCallRun.bat@start MyCRun %1 配置文件在 Sublime Text 3\Packages\C++.sublime-package 。 先备份一下。 修改里面的 C++.sublime-build 为12345678910111213141516171819202122232425&#123; "shell_cmd": "g++ \"$&#123;file&#125;\" -o \"$&#123;file_path&#125;/$&#123;file_base_name&#125;\"", "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "working_dir": "$&#123;file_path&#125;", "selector": "source.c, source.c++", "variants": [ &#123; "name": "Run", "shell_cmd": "g++ \"$&#123;file&#125;\" -o \"$&#123;file_path&#125;/$&#123;file_base_name&#125;\" &amp;&amp; MyCallRun \"$&#123;file_path&#125;/$&#123;file_base_name&#125;.exe\"" // 其实就是这里加了个MyCallRun &#125; ] &#125; C/C++ Sublime Text 3 默认配置好了 c++ 。但是需要你自己把 gcc 目录添加进环境变量 Java Sublime Text 3 默认只运行了 javac，需要自己添加运行。 苦逼看不懂 Sublime 的命令格式，于是把 javac 改成一个自己的bat。（感觉也可以像C++那样用 &amp;&amp; 连起来） 在命令行可直接访问的地方建立 myJRun.bat （我直接放在 jdk/bin 下了）1234567891011121314151617181920212223@ECHO OFF cd %~dp1 ECHO Compiling %~nx1... IF EXIST %~n1.class ( DEL %~n1.class ) javac %~nx1 IF EXIST %~n1.class ( ECHO Running... ECHO ----------------------OUTPUT---------------------- java %~n1 ) 注意不能使用 cls 。 修改java的编译选项（备份好原来的）。 目录：Packages/Java.sublime-package/JavaC.sublime-build123456789&#123; "shell_cmd": "myJRun.bat \"$file\"", "file_regex": "^(...*?):([0-9]*):?([0-9]*)", "selector": "source.java" &#125; 这样以后写的Java代码点 Build 就会自动运行了。 这种办法不能跨平台，再研究研究Sublime自己的方式。 Go 用 Sublime 开发 golang 的环境很简单，只需要安装一个 GoSublime 就差不多了。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L2TP/IPSec配置教程]]></title>
    <url>%2Fyear%2F03%2F19%2F49666%2F</url>
    <content type="text"><![CDATA[上次介绍过在服务器上配置shadowsocks的方法，但这种方法必须要有shadowsocks客户端才能使用，在android和windows下还好，都有客户端可以下载，但在Linux下就比较麻烦了。而我用的正是Linux。所以今天就又配置了L2TP/IPSec，这种连接更加安全，速度也更快，连接更简单。服务器依然用的上次介绍的Vultr，配置的话请看上篇教程。下面进入正题。这次我们采用的是Github上setup-ipsec-vpn这个脚本安装方法，不需要怎么配置，傻瓜式安装。先update一下Ubuntu Debian是sudo apt-get updateCentOS是yum update然后Ubuntu LTS, Debian 系统，使用下列这行代码：1wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh CentOS 系统,使用这行代码:1wget https://git.io/vpnsetup-centos -O vpnsetup.sh &amp;&amp; sudo sh vpnsetup.sh 然后就等待安装好。安装好后，会自动分配 Username，Password，Pre-Shared key,这些随机数会让人崩溃。别担心，可以修改的。Ubuntu、Debian复制、运行以下代码:1234wget https://git.io/vpnsetup -O vpnsetup.shnano -w vpnsetup.sh[Replace with your own values: YOUR_IPSEC_PSK, YOUR_USERNAME and YOUR_PASSWORD]sudo sh vpnsetup.sh CentOS是下面代码:1234wget https://git.io/vpnsetup-centos -O vpnsetup.shnano -w vpnsetup.sh[Replace with your own values: YOUR_IPSEC_PSK, YOUR_USERNAME and YOUR_PASSWORD]sudo sh vpnsetup.sh 把 username passward Pre-shared key分别改成你想设置的。这样服务器端就配置好了。 下面配置客户端先说比较麻烦的Linux吧。我的系统是Ubuntu 16.04 Lts，所以这里只介绍Ubuntu系统的。这里只把代码贴出来，依次复制运行就行。1sudo apt install intltool libtool network-manager-dev libnm-util-dev libnm-glib-dev libnm-glib-vpn-dev libnm-gtk-dev libnm-dev libnma-dev ppp-dev libdbus-glib-1-dev libsecret-1-dev libgtk-3-dev libglib2.0-dev xl2tpd strongswan 1git clone https://github.com/nm-l2tp/network-manager-l2tp.git 1cd network-manager-l2tp 12autoreconf -fi intltoolize 1./configure --disable-static --prefix=/usr --sysconfdir=/etc --libdir=/usr/lib/x86_64-linux-gnu --libexecdir=/usr/lib/NetworkManager --localstatedir=/var --with-pppd-plugin-dir=/usr/lib/pppd/2.4.7 12make sudo make install 12sudo apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.charon sudo apparmor_parser -R /etc/apparmor.d/usr.lib.ipsec.stroke 1sudo apt remove xl2tpd 123456sudo apt install libpcap0.8-dev wget https://github.com/xelerance/xl2tpd/archive/v1.3.6/xl2tpd-1.3.6.tar.gz tar xvzf xl2tpd-1.3.6.tar.gz cd xl2tpd-1.3.6 make sudo make install 这样就好了。点wifi那个标志，编辑连接，增加，VPN里的L2TP，网关是你服务器地址，用户名、密码是你自己设的，再点IPsec设置，ID是你服务器地址，Pre-sharef key是你自己设置的。然后确定。这时候再看你的VPN连接里面就有了，点击连接就OK了。 Windows 10 and 8.x 右键单击系统托盘中的无线/网络图标。 选择 打开网络与共享中心。 单击 设置新的连接或网络。 选择 连接到工作区，然后单击 下一步。 单击 使用我的Internet连接 (VPN)。 在 Internet地址 字段中输入你的 VPN 服务器 IP。 在 目标名称 字段中输入任意内容。单击 创建。 返回 网络与共享中心。单击左侧的 更改适配器设置。 右键单击新创建的 VPN 连接，并选择 属性。 单击 安全 选项卡，从 VPN 类型 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。 单击 允许使用这些协议。确保选中 “质询握手身份验证协议 (CHAP)” 复选框。 单击 高级设置 按钮。 单击 使用预共享密钥作身份验证 并在 密钥 字段中输入你的 VPN IPsec PSK。 单击 确定 关闭 高级设置。 单击 确定 保存 VPN 连接的详细信息。注： 在首次连接之前需要修改一次注册表。请参见下面的说明。 Windows 7, Vista and XP 单击开始菜单，选择控制面板。 进入 网络和Internet 部分。 单击 网络与共享中心。 单击 设置新的连接或网络。 选择 连接到工作区，然后单击 下一步。 单击 使用我的Internet连接 (VPN)。 在 Internet地址 字段中输入你的 VPN 服务器 IP。 在 目标名称 字段中输入任意内容。 选中 现在不连接；仅进行设置以便稍后连接 复选框。 单击 下一步。 在 用户名 字段中输入你的 VPN 用户名。 在 密码 字段中输入你的 VPN 密码。 选中 记住此密码 复选框。 单击 创建，然后单击 关闭 按钮。 返回 网络与共享中心。单击左侧的 更改适配器设置。 右键单击新创建的 VPN 连接，并选择 属性。 单击 选项 选项卡，取消选中 包括Windows登录域 复选框。 单击 安全 选项卡，从 VPN 类型 下拉菜单中选择 “使用 IPsec 的第 2 层隧道协议 (L2TP/IPSec)”。 单击 允许使用这些协议。确保选中 “质询握手身份验证协议 (CHAP)” 复选框。 单击 高级设置 按钮。 单击 使用预共享密钥作身份验证 并在 密钥 字段中输入你的 VPN IPsec PSK。 单击 确定 关闭 高级设置。 单击 确定 保存 VPN 连接的详细信息。注： 在首次连接之前需要修改一次注册表，以解决 VPN 服务器 和/或 客户端与 NAT （比如家用路由器）的兼容问题。 要连接到 VPN： 单击系统托盘中的无线/网络图标，选择新的 VPN 连接，然后单击 连接。如果出现提示，在登录窗口中输入 你的 VPN 用户名 和 密码 ，并单击 确定。最后你可以到 这里 检测你的 IP 地址，应该显示为你的 VPN 服务器 IP。 OS X 打开系统偏好设置并转到网络部分。 在窗口左下角单击 + 按钮。 从 接口 下拉菜单选择 VPN。 从 VPN类型 下拉菜单选择 IPSec 上的 L2TP。 在 服务名称 字段中输入任意内容。 单击 创建。 在 服务器地址 字段中输入你的 VPN 服务器 IP。 在 帐户名称 字段中输入你的 VPN 用户名。 单击 鉴定设置 按钮。 在 用户鉴定 部分，选择 密码 单选按钮，然后输入你的 VPN 密码。 在 机器鉴定 部分，选择 共享的密钥 单选按钮，然后输入你的 VPN IPsec PSK。 单击 好。 选中 在菜单栏中显示 VPN 状态 复选框。 单击 高级 按钮，并选中 通过VPN连接发送所有通信 复选框。 单击 TCP/IP 选项卡，并在 配置IPv6 部分中选择 仅本地链接。 单击 好 关闭高级设置，然后单击 应用 保存VPN连接信息。要连接到 VPN： 使用菜单栏中的图标，或者打开系统偏好设置的网络部分，选择 VPN 并单击 连接。 Android 启动 设置 应用程序。 在 无线和网络 部分单击 更多…。 单击 VPN。 单击 添加VPN配置文件 或窗口右上角的 +。 在 名称 字段中输入任意内容。 在 类型 下拉菜单选择 L2TP/IPSec PSK。 在 服务器地址 字段中输入你的 VPN 服务器 IP。 在 IPSec 预共享密钥 字段中输入你的 VPN IPsec PSK。 单击 保存。 单击新的VPN连接。 在 用户名 字段中输入你的 VPN 用户名。 在 密码 字段中输入你的 VPN 密码。 选中 保存帐户信息 复选框。 单击 连接。 iOS 进入设置 -&gt; 通用 -&gt; VPN。 单击 添加VPN配置…。 单击 类型 。选择 L2TP 并返回。 在 描述 字段中输入任意内容。 在 服务器 字段中输入你的 VPN 服务器 IP。 在 帐户 字段中输入你的 VPN 用户名。 在 密码 字段中输入你的 VPN 密码。 在 密钥 字段中输入你的 VPN IPsec PSK。 启用 发送所有流量 选项。 单击右上角的 存储。 启用 VPN 连接。 好了，在Google的世界里尽情畅游吧！！！]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jinja2 简明教程]]></title>
    <url>%2Fyear%2F03%2F18%2F22581%2F</url>
    <content type="text"><![CDATA[Flask包含强大的Jinja模板语言，学习Flask之前要先学习一下jinja。在Jinja2之前，已经有类似的模板语言，如JSP，Django。这些语言实际上包含了变量以及一些编程逻辑，当它们被呈现为HTML时，它们会被实际值取代。变量和/或逻辑放置在标签或分隔符之间。例如，Jinja模板% … %用于表达式或逻辑（比如for循环），同时 … 用于向用户输出表达式或变量的结果。后者标记在呈现时被替换为一个或多个值，并且最终由用户看到。 Jinja模板只是.html文件。按照惯例，它们位于Flask项目的”/templates”目录中。如果你熟悉字符串格式化或插值，模板语言遵循相似的逻辑类型-只是整个HTML页面的规模。 简单示例运行这些示例(pip insatll jinja2)之前，确保安装了Jinja。12345678Python&gt;&gt;&gt; from jinja2 import Template&gt;&gt;&gt; t = Template("Hello &#123;&#123; something &#125;&#125;!")&gt;&gt;&gt; t.render(something = "world")u'Hello world!'&gt;&gt;&gt; t = Template("My favorite numbers: &#123;% for n in range(1,10) %&#125; &#123;&#123; n &#125;&#125;" "&#123;% endfor %&#125;")&gt;&gt;&gt; t.render()u'My favorite numbers: 1 2 3 4 5 6 7 8 9' 注意呈现给用户的实际输出如何落在标签内。 Flask 示例创建以下项目结构：123├── requirements.txt├── run.py└── templates 激活 virtualenv 安装 flask1$ pip install flask 添加下列代码到run.py1234567891011from flask import Flask, render_templateapp = Flask(__name__)@app.route("/")def template_test(): return render_template('template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5])if __name__ == '__main__': app.run(debug=True) 这里我们建立路由/,通过render_template()函数将 template.html 传递到 /地址下。这个函数必须有一个模板名字，你也可以通过关键字参数将值传到模板中。如本例中的my_string和my_list。创建下列模板：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Flask Template Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt; &lt;style type="text/css"&gt; .container &#123; max-width: 500px; padding-top: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;p&gt;My string: &#123;&#123;my_string&#125;&#125;&lt;/p&gt; &lt;p&gt;Value from the list: &#123;&#123;my_list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;Loop through the list:&lt;/p&gt; &lt;ul&gt; &#123;% for n in my_list %&#125; &lt;li&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在templates文件夹中保存为template.html。注意这些模板标签，你能猜到会输出什么吗？运行后浏览器打开http://127.0.0.1:5000/ ，你会看到： 值得注意的是，Jinja只支持一些控制结构 - if语句和for循环是两个主要结构。语法与Python类似，不同之处在于不需要冒号，并且块的终止是使用endifor endfor而不是由空白完成的。您还可以完成控制器或视图中的逻辑，然后使用模板标记将每个值传递给模板。但是，在模板本身内执行这样的逻辑要容易得多。 模板继承模板通常利用继承，其中包含一个基模板，用于定义所有后续子模板的基本结构。使用% extends % 和 % block %实现继承。这个用例很简单：随着应用程序的增长，并且您继续添加新模板，您需要保持常见代码（如HTML导航栏，Javascript库，CSS样式表等）同步，这是很多工作。使用继承，我们可以将这些常见的部分移动到父/基模板，以便我们可以创建或编辑这样的代码，并且所有子模板都将有该代码。 您应该始终在您的基本模板中添加尽可能多的循环代码，以节省您未来的时间，这将远远超过最初的投资时间。 让我们将继承添加到我们的示例中。创建基模板：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Flask Template Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt; &lt;style type="text/css"&gt; .container &#123; max-width: 500px; padding-top: 100px; &#125; h2 &#123;color: red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;br&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;br&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;/div&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 保存为layout.html.你注意到% block %标签了吗？这定义了子模板可以填充的块（或区域）。此外，这只是通知模板引擎子模板可能会覆盖模板中的这个块。 可以将这些视为占位符，由来自子模板的代码填充。 接下来更新 template.html:1234567891011121314&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;h3&gt; This is the start of my child template&lt;/h3&gt; &lt;br&gt; &lt;p&gt;My string: &#123;&#123;my_string&#125;&#125;&lt;/p&gt; &lt;p&gt;Value from the list: &#123;&#123;my_list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;Loop through the list:&lt;/p&gt; &lt;ul&gt; &#123;% for n in my_list %&#125; &lt;li&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;h3&gt; This is the end of my child template&lt;/h3&gt;&#123;% endblock %&#125; so,% extends %告诉模板引擎该模板“扩展”了另一个模板layout.html。换句话说，这建立了模板之间的链接。运行。你会看到一个常见的用例是添加导航栏。添加以下代码到基模板layout.html,紧跟在开始标签后:123456789101112131415161718192021222324252627282930313233343536373839&lt;nav class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;Jinja!&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left" role="search"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control" placeholder="Search"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;Dropdown &lt;b class="caret"&gt;&lt;/b&gt;&lt;/a&gt; &lt;ul class="dropdown-menu"&gt; &lt;li&gt;&lt;a href="#"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 现在每个子模板都将具有相同的导航栏。从Java哲学中引用一条真理“Write once, use anywhere.” Super Blocks如果你需要从基本模板渲染块，使用 super block.1&#123;&#123; super() &#125;&#125; 添加页脚到基模板:1234567&lt;div class="footer"&gt; &#123;% block footer %&#125; Watch! This will be added to my base and child templates using the super powerful super block! &lt;br&gt; &lt;br&gt; &#123;% endblock %&#125;&lt;/div&gt; 添加后的代码应该是这样:12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Flask Template Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" media="screen"&gt; &lt;style type="text/css"&gt; .container &#123; max-width: 500px; padding-top: 100px; &#125; h2 &#123;color: red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;br&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;br&gt; &lt;h2&gt;This is part of my base template&lt;/h2&gt; &lt;br&gt; &lt;div class="footer"&gt; &#123;% block footer %&#125; Watch! This will be added to my base and child templates using the super powerful super block! &lt;br&gt; &lt;br&gt; &lt;br&gt; &#123;% endblock %&#125; &lt;/div&gt; &lt;/div&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.min.js"&gt;&lt;/script&gt; &lt;script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行 添加 super block到 template.html1234567891011121314151617&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;h3&gt; This is the start of my child template&lt;/h3&gt; &lt;br&gt; &lt;p&gt;My string: &#123;&#123;my_string&#125;&#125;&lt;/p&gt; &lt;p&gt;Value from the list: &#123;&#123;my_list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;Loop through the list:&lt;/p&gt; &lt;ul&gt; &#123;% for n in my_list %&#125; &lt;li&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;h3&gt; This is the end of my child template&lt;/h3&gt; &#123;% block footer %&#125; &#123;&#123;super()&#125;&#125; &#123;% endblock %&#125;&#123;% endblock %&#125; 在浏览器中查看 Suoer block用于父模板和子模板共享的通用代码，例如title两个模板共享标题的一部分，然后你只需要传入另一部分。例如父模板123&#123;% block heading %&#125; &lt;h1&gt;&#123;% block page %&#125;&#123;% endblock %&#125; - Flask Super Example&lt;/h1&gt;&#123;% endblock %&#125; 子模板1234&#123;% block page %&#125;Home&#123;% endblock %&#125;&#123;% block heading %&#125; &#123;&#123; super() &#125;&#125;&#123;% endblock %&#125; 看下效果可以试试% block page %Home% endblock %从子模板中移除会发生什么。 尝试一下使用相同的方法更新title 除了硬编码，也可以使用动态方法更新template.html中的两个代码片段：1&#123;％block title％&#125; &#123;&#123;title&#125;&#125; &#123;％endblock％&#125; 1&#123;％block page％&#125; &#123;&#123;title&#125;&#125; &#123;％endblock％&#125; 现在我们需要title从我们的控制器run.py中将一个变量传递给我们的模板：12345@app.route("/")def template_test(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="Home") 测试一下。 宏在Jinja中，我们可以使用宏来抽象反复使用的常用代码片段，以避免重复我们自己。例如，突出显示导航栏上当前页面的链接（活动链接）很常见。否则，我们不得不使用if/ elif/ else语句来确定活动链接。使用宏，我们可以将这些代码抽象为一个单独的文件。将 macros.html 添加到 templates目录中：1234567&#123;% macro nav_link(endpoint, name) %&#125;&#123;% if request.endpoint.endswith(endpoint) %&#125; &lt;li class="active"&gt;&lt;a href="&#123;&#123; url_for(endpoint) &#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% else %&#125; &lt;li&gt;&lt;a href="&#123;&#123; url_for(endpoint) &#125;&#125;"&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;% endif %&#125;&#123;% endmacro %&#125; 在这里，我们使用Flask的请求对象，默认情况下它是Jinja的一部分，用于检查请求的端点，然后将该active类分配给该端点。使用nav navber-nav基本模板中的类更新无需列表：12345&lt;ul class="nav navbar-nav"&gt; &#123;&#123; nav_link('home', 'Home') &#125;&#125; &#123;&#123; nav_link('about', 'About') &#125;&#125; &#123;&#123; nav_link('contact', 'Contact Us') &#125;&#125;&lt;/ul&gt; 另外，请确保在模板顶部添加导入：% from “macros.html” import nav_link with context %。注意我们如何调用nav-link宏并传递两个参数，即端点（来自我们的控制器）和我们想要显示的文本。 最后，让我们向控制器添加三个新端点：1234567891011121314151617@app.route("/home")def home(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="Home")@app.route("/about")def about(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="About")@app.route("/contact")def contact(): return render_template( 'template.html', my_string="Wheeeee!", my_list=[0,1,2,3,4,5], title="Contact Us") 刷新页面 过滤器Jinja使用过滤器来修改变量，主要用于格式化目的。例如1&#123;&#123; num | round &#125;&#125; 这将对num变量近似取值。如果传值 num=46.99, 将输出47.0.关于过滤器的更多知识，你可以看这里.在某些情况下，你可以在括号中指定可选参数。例如1&#123;&#123;list | join（'，'）&#125;&#125; 这将通过逗号分隔符加入列表。测试一下，添加下列代码到 template.html.1&lt;p&gt;Same list with a filter: &#123;&#123; my_list|join(', ') &#125;&#125;&lt;/p&gt; 除了内置的过滤器，我们也可以自己创建。让我们添加一个我们自己的。一个常见的例子是自定义日期时间过滤器。 创建应用程序后，将以下代码添加到我们的控制器 - app = Flask(name)：123456@app.template_filter()def datetimefilter(value, format='%Y/%m/%d %H:%M'): """convert a datetime to a different format.""" return value.strftime(format)app.jinja_env.filters['datetimefilter'] = datetimefilter 使用@app.template_filter()装饰器，我们将datetimefilter()函数注册为过滤器。 过滤器的默认名称只是该函数的名称; 然而，你可以通过传递一个参数来定制它 - 例如，@app.template_filter(formatdate)。 接下来，我们将过滤器添加到Jinja环境中，使其可访问。现在可以使用了。将以下代码添加到我们的子模板中：1&lt;h4&gt;Current date/time: &#123;&#123; current_time | datetimefilter &#125;&#125;&lt;/h4&gt; 最后，只需将日期时间传递给我们的模板：1current_time=datetime.datetime.now() 测试一下 这只是简明教程，详细教程请看这里。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Jinja2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表的基本概念]]></title>
    <url>%2Fyear%2F03%2F18%2F52829%2F</url>
    <content type="text"><![CDATA[一、线性表的定义线性表：零个或多个数据元素的有限序列。几个关键的地方。 首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都只有一个前驱和后继。 然后，线性表强调是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中。 如果用数学语言来定义。可如下： 若将线性表记为(a1，…，ai-1，ai，ai+1，…，an)，则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i = 1，2，…，n-1时，ai有且仅有一个直接后继，当i = 2 , 3 , … , n时，ai有且仅有一个直接前驱。 所以线性表元素的个数n(n ≥ 0)定义为线性表长度，当n=0时，称为空表。 在非空表中的每个数据元素都有一个确定的位置，如a1是第一个数据元素，an是最后一个数据元素，ai是第i个数据元素，称i为数据元素ai在线性表中的位序。 举几个例子，来判断是否是线性表。 第一个：一年的星座列表，是不是线性表呢？ 答：当然是，星座通常都是白羊座开头，双鱼座收尾，当中的星座都有前驱后继，而且一共才12个，所以完全符合线性表的定义。 第二个：公司的组织交媾，总经理管理几个总监，每个总监管理几个经理，每个经理管理各自的下述和员工。这样的组织架构是不是线性关系呢？ 答：不是，为什么不是呢？因为每一个元素，都有不止一个后继，所以它不是线性表。 第三个：班级同学的友谊关系，是不是线性表呢？ 答：不是，因为每个人都可以和多个同学建立友谊，不满足线性的定义。 第四个：班级同学的点名册，是不是线性表？是不是点名册？ 答：是，这和刚才的友谊关系是完全不同的，因为它是有限序列，也满足类型相同特点，这个点名册中，每个元素除学生的学号外，还可以有同学的姓名、性别、出生年月什么的，这其实就是我们之前将的数据项。在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 二、线性表的抽象数据类型线性表的抽象数据类型定义如下：12345678910111213141516ADT 线性表(List)Data 线性表的数据对象集合为&#123;a1,a2,....,an&#125;,每个元素的类型均为DataType。其中除了，第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation InitList(*L):初始化操作，建立一个空的线性表。 ListEmpty(L):若线性表为空，返回true，否则返回false。 ClearList(*L):线性表清空。 GetElem(L,i,*e):将线性表L中第i个位置元素返回给e。 LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果 查找成功,返回该元素在表中的序列号；否则，返回0表示失败。 ListInsert(*L,i,e):在线性表的第i个位置插入元素e。 ListDelete(*L,i,*e):删除线性表L中的第i个元素，并用e返回其值 ListLength(L):返回线性表L的元素个数。对于不同的应用，线性表的操作时不同的，上述操作时最基本的，问题中设计的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。 比如，要实现两个线性表集合A和B的并集操作。即要使得集合A = A ∪ B，说白了，就是把存在集合B中但并不存在中的数据元素插到A中即可。 仔细分析一下这个操作，发现我们只要循环集合B中的元素，判断是否存在A中，若不存在，则插到A中即可。思路应该是很容易想到的。 假设我们La表示集合A，Lb表示集合B，则实现代码如下：12345678910111213141516//将所有的在线性表Lb中但不在La中的元素插入到La中void unionL(List *La , List Lb)&#123; int La_len,Lb_len,i; ElemType e; La_len = ListLength(*La); Lb_len = ListLength(*Lb); for(i = 0 ;i ≤ Lb;i++) &#123; GetElem(Lb,i,*e);//取出Lb中第i个数据元素赋给e if(!LocateElem(*La,e))//La中不存在和e元素相同的数据元素 &#123; ListInsert(La,++La_len,e);//插入 &#125; &#125;&#125; 这里我们对于union操作，用到了前面线性表基本操作ListLength、GetElem、LocateElem，ListLength等，可见，对于复杂的个性化的操作，其实就是把基本操作组合起来实现的。 三、线性表的顺序存储结构1.顺序存储定义说了这么多的线性表，我们来看线性表的物理结构第一种——顺序存储结构。 线性表的顺序存储结构，指定的是用一段地址连续的存储单元一次存储线性表的数据元素。 2.顺序存储方式线性表的顺序存储方式，说白了，就是在内存中找了一块地方，把一定内存空间占了，然后把相同数据类型的数据元素一次存在在里面。既然线性表的数据元素的类型都相同，所以用C语言的一维数组来实现顺序存储结构，即把第一个数据元素存储到数组下表为0的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。 为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，它是存储空间的起始位置。 线性表中，我们估算这个线性表的最大存储容量，建立一个数组，数组的长度就是最大存储容量。 我们已经有了起始位置，也有了最大的容量，于是我们可以在里面增加数据了。随着数据的插入，我们线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。 来看线性表的顺序存储的结构代码。1234567#define MAXSIZE 20 //存储空间初始分配量typedef int ElemType;//ElemType根据实际情况而定，这里假设为inttypedef struct&#123; ElemType data[MAXSIZE];//数组存储数据元素,最大值为MAXSIZE int length;//线性表当前长度&#125;SqList; 这里我们发现描述顺序存储结构需要三个属性： ①存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。 ②线性表的最大存储容量：数组长度MaxSize。 ③线性表的当前长度：length。 3.数组长度与线性表长度区别数组长度是存放线性表的存储空间的长度，存储空间分配完一般是不变的。 线性表长度是线性表中元素数据的个数，随着线性表插入和删除操作的进行，这个量是变化的。 在任意时刻，线性表的长度应该小于等于数组的长度。 4.地址计算方法线性表的起始是从1开始的，可数组却是从0开始第一个下标的，于是线性表中第i个元素，存储在数组下标为i - 1的位置。 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。 由于每个数据元素，不管他是整型、实型还是字符型，它都是需要占用一定的存储空间的。假设占用的是c个存储单元，那么线性表中第i + 1个元素的存储位置和第i个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）。1LOC(ai+1) = LOC(ai) + c 所以对于第i个数据元素ai的存储位置可以由a1推算得出：1LOC(ai) = LOC(ai) + (i - 1) * c 通过这个公式，随时可以算出线性表中任意位置的地址，不管他是第一个还是最后一个，都是相同的事件。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此我们算法中学到的时间复杂度的概念来说，它的存取时间的性能为O(1)。我们通常把具有这一特点的存储结构称为随机存取结构。 四、顺序存储结构的插入与删除1.获得元素操作对于线性表的顺序存储结构来说，我们要实现GetElem操作，即将线性表L中的第i个位置元素返回，其实是非常简单的。就程序而言，只要第i个元素在下标范围内，就是把数组第i - 1下表值返回即可。 来看代码：123456789101112131415#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//Status是函数的类型，其值是函数结果状态代码，如OK等//初始条件：顺序线性表L已经存在，1 ≤ i ≤ ListLength(L)//操作结果：用e返回L中第i个元素的值Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length == 0 || i &lt; 1 || i &gt; L.length) return ERROR; *e = L.data[i - 1]; return OK;&#125; 注意这里返回值类型Status是一个整型，返回OK代表1，ERROR代表0。 2.插入操作刚才我们也谈到，这里的时间复杂度为O(1)。我们现在来考虑，如果我们要实现ListInsert(*L，i，e)，即在线性表L中第i个位置插入新元素e，应该如何操作？ 插入算法的思路： ①如果插入位置不合理，抛出异常； ②如果线性表长度大于等于数组长度，则抛出异常或动态增加容量； ③从最后一个元素开始向前遍历到第i个元素，分别将它们都向后移一位； ④将要插入元素填入位置i处； ⑤表长加1。 实现代码如下：12345678910111213141516171819202122//初始条件:顺序线性表L已存在,1 ≤ i ≤ ListLength(L)//操作结果:在L的第i个位置插入新的数据元素e,L的长度加1Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if(L-&gt;length == MAXSIZE)//当线性表已满 return ERROR; if(i &lt; 1 || i &gt;L-&gt;length + 1)//当i不在范围内时 &#123; return ERROR; &#125; if(i &lt;= L-&gt;length)//若插入数据位置不在表尾 &#123; for(k = L-&gt;length-1;k &gt; i-1;k--) &#123; L-&gt;data[k + 1] = L-&gt;data[k]; &#125; &#125; L-&gt;data[i - 1] = e;//将新元素插入 L-&gt;length++; return OK;&#125; 3.删除操作删除算法的思路： ①如果删除位置不合理，抛出异常； ②取出删除元素； ③从删除元素位置开始遍历到最后一个元素位置，分别将它们向前移动一个位置； ④表长减1。 实现代码如下：123456789101112131415161718//初始条件:顺序线性表L已经存在，1 &lt;= i &lt;= ListLength(L)//操作结果:删除L的第i个元素,并用e返回其值,L的长度减1Status ListDelete(SqList *L ,int i , ElemType *e)&#123; int k; if(L-&gt;length == 0)//线性表为空 return ERROR; if(i &lt; 1 || i &gt; L-&gt;length)//删除位置不正确 return ERROR; *e = L-&gt;data[i]; if(i &lt; L-&gt;length) &#123; for(k = i;k &lt; L-&gt;length;k++) L-&gt;data[k - 1] = L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 现在，我们来分析一下，插入和删除的事件复杂度。 现在我们来看最好的情况，如果一个元素要插入到最后一个位置，或者删除最后一个位置，此时时间复杂度为O(1)，因为不需要移动元素的。 最坏的情况呢，如果元素要插入到第一个位置或者删除第一个元素，此时时间复杂度是多少呢？那就意味着所有元素向后或者向前，所以这个时间复杂度为O(n)。 至于平均的情况，由于元素插入到第i个位置，或者删除第i个元素，需要移动n - i个元素，每个位置插入或删除元素的可能性是相同的，也就是位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间那个元素的移动次数相等，为(n - 1)/ 2。 根据时间复杂度的推导，平均时间复杂度还是O(n)。 这说明说明？线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。 4.线性表顺序存储结构的优缺点优点①无须为表中元素之间的逻辑关系而增加额外的存储空间 ②可以快速地存取表中任一位置的元素 缺点 ①插入和删除需要移动大量元素 ②当线性表长度变化较大时，难以确定存储空间的容量 ③造成存储空间的“碎片” 五、线性表的链式存储结构1.线性表链式存储结构定义线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些元素可以存在内存未被占用的任意位置。 以前在顺序结构中，每个元素数据只需要存储数据元素信息就可以了。现在在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 因此，为了表示每个数据元素ai与其直接后级元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。 n个结点(ai的存储映像)链结成一个链表，即为线性表(a1,a2,….,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。 对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。 最后一个，当然意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示）。 有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。 2.头指针与头结点的异同头指针与头结点的异同点。 头指针 ① 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 ②头指针具有标识作用，所以常用头指针冠以链表的名字 ③无论链表是否为空，头指针均不为空。头指针是链表的必要元素。 头结点 ①头结点是为了操作的统一和方便而设立的，放在第一元素的结点之间，其数据域一般无意义。 ②有了头结点，对在第一元素结点前插入结点，其操作与其它结点的操作就统一了。 ③头结点不一定是链表必须要素。 3.线性链表式存储结构代码描述若线性链表为空表，则头结点的指针域为“空”。 单链表中，我们在C语言中可用结构指针来描述。1234567//线性表的单链表存储结构typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList;//定义LinkList 在这个结构定义中，我们也就知道，结点由存放数据元素的数据域和存放后继结点地址的指针域组成。 假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p-&gt;data来表示，p-&gt;data的值是一个数据元素，结点ai的指针可以用p-&gt;next来表示，p-&gt;next的值是一个指针。p-&gt;next指向谁呢？当然是指向第i + 1个元素，即指向ai+1。也就是说p-&gt;data = ai，那么p-&gt;next-&gt;data=ai+1 六、单链表的读取在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置使很容易的。但在单链表中，由于第i个元素到底在哪？没办法一开始就知道，必须从头开始找。因此，对于单链表实现获取第i个元素的操作GetElem，在算法上，相对麻烦一些。 获得链表第i个数据的算法思路： 声明一个指针p指向链表第一个结点，初始化j从1开始。 当j &lt; i 时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1; 若链表末尾p为空，则说明第i个结点不存在； 否则查找成功，返回结点p的数据。 实现代码如下：123456789101112131415161718//初始条件:顺序线性表L已存在,1 ≤ i ≤ ListLength(L)//操作结果:用e返回L中第i个数据元素的值Status GetElem(LinkList L,int i,ElemType *e)&#123; int j; LinkList p;//声明一指针 p = L-&gt;next;//让p指向链表L的第一个结点 j = 1;//j为计数器 while(p &amp;&amp; j &lt; i)//p不为空且计数器j还没有等于i时，循环继续 &#123; p = p-&gt;next;//让p指向下也结点 ++j; &#125; if(p || j &gt; i) return ERROR;//第i个结点不存在 *e = p-&gt;data;//取第i个结点的数据 return OK;&#125; 说白了，就是从头开始找，直到第i个结点为止。由于这个算法复杂度取决于i的位置，当i = 1时，不需要变量，而当i = n时则遍历n - 1次才可以。因此最坏情况的时间复杂度是O(n)。 由于单链表的结构没有定义表长，所以不知道事先循环多少次，因此也就不方便使用for来控制循环。其主要核心思想是“工作指针后移”，这其实也是很多算法常用技术。 八、单链表的插入与删除1.单链表的插入假设存储元素e的结点为s，要实现结点p、p-&gt;next和s之间的逻辑关系的变化，只需要将s插到结点p和p-&gt;next之间即可。 根本不需要惊动其他结点，只需要让s-&gt;next和p-&gt;next的指针做一点改变。123//下面两句不可交换顺序s-&gt;next = p-&gt;next;p-&gt;next = s; 单链表第i个数据插入结点的算法思路： 声明一指针p指向链表头结点，初始化j从1开始; 当j &lt; i时，就遍历链表，让p的指针向后移动，不断指向下一结点,j累加1 若到链表末尾p为空，则说明第i个结点不存在; 若查找成功，在系统中生成一个空节点s； 将数据元素e赋给s-&gt;data； 单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s; 返回成功 实现代码算法如下：12345678910111213141516171819202122//初始条件:顺序线性表L已存在,1≤i≤ListLength(L)//操作结果:在L中第i个结点位置之前插入新的数据元素,L的长度加1Status ListInsert(LinkList *L , int i , ElemType e)&#123; int j = 1; LinkList p,s; p = *L; while( p &amp;&amp; j &lt; i) //寻找第i个结点 &#123; p = p-&gt;next; ++j; &#125; if( !p || j &gt; 1) &#123; return ERROR;//第i个结点不存在 &#125; s = (LinkList)malloc(sizeof(Node));//生成新结点 s-&gt;data = e; s-&gt;next = p-&gt;next;//将p的后继结点赋值给s的后继 p-&gt;next = s;//将s赋给p的后继 return OK;&#125; 在这段算法代码中，我们用到了C语言的malloc标准函数，它的作用就是生成一个新的结点，其类型与Node是一样的，其实质就是在内存中开辟了一段空间，用了存放数据e的s结点。 2.单链表的删除现在我们再来看单链表的删除。设存储元素ai的结点为q，要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向他的后继结点即可。 我们所要做的，实际上就是一步，p-&gt;next = p-&gt;next-&gt;next;，用q来取代p-&gt;next即是：12q = p-&gt;next;p-&gt;next = q-&gt;next; 也就是说把p的后继结点改成p的后继的后继结点。 单链表第i个数据删除结点的算法思路： 声明一指针p指向链表头指针，初始化j从1开始； 当j &lt; i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，i累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，将欲删除的结点p-&gt;next 赋给q； 单链表的删除标准与p-&gt;next = q-&gt;next； 将q结点中的数据赋给e，作为返回; 释放q结点 返回成功 实现代码算法如下：123456789101112131415161718192021//初始条件:顺序线性表L已存在,1≤ i ≤ListLength(L)//操作结果:删除L的i个结点,并用e返回其值,L的长度减1Status ListDelete(LinkList *L,int i,ElemType *e)&#123; int j; Link p,q; p = *L; j = 1; while(p-&gt;next &amp;&amp; j &lt; i)//遍历寻找第i - 1个结点 &#123; p = p-&gt;next; ++j; &#125; if( !(p-&gt;next) || j &gt; i) return ERROR;//第i个结点不存在 q = p-&gt;next; p-&gt;next = q-&gt;next;//将q的后继赋给p的后继 *e = q-&gt;data;//将q结点中的数据给e free(q);//让系统回收此结点，释放内存 return OK;&#125; 分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就是插入和删除结点。 从整个算法来说，我们很容易推导出：它们的时间复杂度都是O(n)。 如果我们不知道第i个结点的指针位置，单链表数据结构在插入和删除操作上，与线下顺序存储结构是没有太大优势的。但如果，我们希望从第i个位置，插入10个结点，对于顺序结构意味着，每次都要移动n - i个结点，每次都是O(n)。而单链表，我们只需在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，事件复杂度为O(1)。 显然，对于插入和删除数据越频繁的操作，单链表的优势就越明显。 八、单链表的整表创建顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么几种，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置使不需要预先分配划定的，可以根据系统的情况和实际的需求即可生成。 所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，一次建立各元素结点，并逐个插入链表。单链表整表创建的思路算法： 声明一指针p和计数器变量1；初始化一空链表；让L的头结点的指针指向NULL，即建立一个带头结点的单链表；循环： 生成一新结点赋值给p; 随机生成一数字赋给p的数据域p-&gt;data; 将p插到头结点与前一个新节点之间的位置。 实现代码如下：12345678910111213141516//随机产生n个元素的值，建立带表头结点的单链表线性表L(头插法)void CreateListHead(LinkList *L,int n)&#123; LinkList p; int i; srand(time(0));//初始化随机数种子 *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL;//先建立一个带头结点的单链表 for(i = 0;i &lt; n;i++) &#123; p = (LinkList)malloc(sizoef(Node));//生成新的结点 p-&gt;data = rand() % 100 + 1;//随机生成100以内的数字 p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; //插入到表头 &#125;&#125; 这段代码里，我们始终让新结点在第一的位置上，我们把这种算法简称为头插法。 可事实上，我们还可以把新结点放在最后。这才是排队时的正常思维。我们每次新结点都插在终端结点的后面，这种算法称之为尾插。 实现代码算法如下：1234567891011121314151617//随机产生n个元素的值,建立带表头结点的单链线性表L(尾插法)void CreateListTail(LinkList *L,int n)&#123; LinkList p,r; int i; srand(time(0));//初始化随机数种子 *L = (LinkList)malloc(sizeof(Node));//为整个线性表 r = *L;//r为指向尾部的结点 for(i = 0;i &lt; n;i++) &#123; p = (Node *)malloc(sizeof(Node));//生成新结点 p-&gt;data = rand() % 100 + 1;//随机生成100以内的数字 r-&gt;next = p;//将表尾终端结点的指针指向新结点 r = p; //就那个当前新结点定义为表尾终端结点 &#125; r-&gt;next = NULL;//表示当前链表结束&#125; 注意L与r的关系，L指整个单链表，而r指向尾节点的变量，r会随着循环不断地变化结点，而L则是随着循环增长为一个多结点的链表。 这里需要解释一下，r-&gt;next = p的意思，其实就是将刚才的表尾终端结点r的指针指向新结点p。 九、单链表的整表删除当我们不打算使用这个单链表时，我们需要把它销毁，其实也就是在内存中将它释放掉，以便于留出空间给其他程序或软件使用。 单链表整表删除的算法思路如下： 声明一结点p和q； 将第一个结点赋值给p； 循环 将下一结点赋值给q; 释放p; 将q赋值给p。 实现代码算法如下:1234567891011121314//初始条件:顺序线性表L已经存在，操作结果：将L重置为空表Status ClearList(LinkList *L)&#123; LinkList p,q; p = (*L)-&gt;next;//p指向第一个结点 while(p)//没到表尾 &#123; q = p-&gt;next; free(p); p = q; &#125; (*L)-&gt;next = NULL;//头结点指针域为空 return OK;&#125; 十、单链表结构与顺序存储结构优缺点简单地对单链表结构和顺序存储结构作对比。 1、存储分配方式： 顺序存储结构有一段连续的存储单元依然存储线性表的数据元素。 单链表采用链式存储结构，用一组任意的存储单元存放线性表的玩意。 2、时间性能：查找： 顺序存储结构O(1) 单链表O(n) 插入与删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在线出某位置的指针后，插入和删除时间仅为O(1) 3、空间性能 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。 通过上面的对比，我们可以得出一些经验性的结论： ① 若线性表需要频繁查找，很少进入插入和删除操作时，宜采用顺序存储结构。 若需要频繁插入和删除时，宜采用单链表结构。 比如游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况下都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家游戏过程中，可能随时增加或删除，此时应该用单链表比较合适。当然，这只是简单地类比。现实生活中的软件开发，要考虑的问题会复杂得多。 ②当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不用考虑存储空间大小问题。而如果事先知道线性表的大致长度，比如一年12个月，这种用顺序存储结构效率会高很多。 总之，线性表的顺序存储结构和单链表结构各有其优点，不是简单地说哪个不好，需要根据实际情况，来综合平衡采用哪种数据更能满足和达到需求和性能。 十一、静态链表C语言具有指针能力，使得它可以非常容易地操作内存中的地址和数据，这比其他高级语言更加方便灵活。 后来的面向对象语言，如Java、C#等，虽不使用指针，但因为启用了对象引用机制，从某种角度上也间接实现了指针的某些作用。但对于一些语言，如Basic、Fortran等早期的编程高级语言，由于没有指针，链表结构就没办法实现。 有人想出用数组来代替指针，来描述链表。 首先我们用数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下表都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素后继在数组中的下表，我们把cur叫做游标。 我们把这种用数组描述的链表叫静态链表，这种描述方法还有起名叫做游标实现法。 为了我们方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间可以方便插入不至于溢出。1234567//线性表的静态链表存储结构#define MAXSIZE 1000//假设链表的最大长度1000typedef struct&#123; ElemType data; int cur;//游标(Cursor),为0时表示无指向&#125;Component,StaticLinkList[MAXSIZE]; 另外我们对数组的第一个和最后一个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下表;而数组的最后一个元素的cur则存放第一个有数值的元素的下表，相当于单链表中的头结点作用，当整个链表为空时，则为0²。12345678910//将一维数组space中个分量链成一备用链表//space[0].cur为头指针，"0"表示空指针Status InitList(StaticLinkList space)&#123; int i; for(i = 0;i &lt; MAXSIZE - 1;i++) space[i].cur = i + 1; space[MAXSIZE - 1].cur = 0;//目前静态链表为空 return OK;&#125; 1.静态链表的插入操作静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，不需要时释放。 我们前面说过，在动态链表中，结点的申请和释放分别借用malloc()和free()两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表一样的申请和释放问题，所以我们需要自己实现这两个函数。 为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的以及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可从备用链表上取得第一个结点作为待插入的新结点。1234567891011//若备用空间链表为空，则返回分配的结点下表，否则返回0int Malloc_SLL(StaticLinkList space)&#123; int i = space[0].cur;//当前数组的第一个元素的Cur存的值 if(space[0].cur) &#123; space[0].cur = space[i].cur;//由于要拿出一个分量来使用 //所以我们,就得把它的下一个分量用作备用 &#125; return i;&#125; 插入元素123456789101112131415161718192021//在L中第i个元素之前插入新的数据元素eStatus ListInsert(StaticLinkList L, int i,ElemType e)&#123; int j,k,l; k = MAX_SIZE - 1;//注意k首先是最后一个元素的下表 if(i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L);//获得空闲分量的下标 if(j) &#123; L(j).data = e;//将数据赋值给此分量的下表 for(l = 1;l &lt;= i - 1;l++)//相当于循环链表，找到第i-1位 &#123; k = L[k].cur; &#125; L[j].cur = L[k].cur;//新的第i个元素元素指向原本第i个元素 L[k].cur = j;//第i - 1个元素指向新的第i个元素 return OK; &#125; return ERROR;&#125; 就这样，我们实现了在数组中，实现不移动元素，却插入了数据的操作。 2.静态链表的删除操作和前面一样，删除元素时，原来是需要释放结点的函数free()。我们也要自己实现它。123456789101112131415//删除在L中第i个数据元素eStatus ListDelete(StaticLinkList L,int i)&#123; int j , k; if(i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAX_SIZE - 1; for(j = 1;j &lt; = i - 1;j++)//相当于遍历链表 &#123; k = L[k].cur; &#125; j = L[k].cur;//把要删除的数组下标赋值给j Free_SLL(L,j);//调用删除函数 return OK;&#125; 123456//将下表为k的空闲结点回收到备用链表void Free_SSL(StaticLinkList space,int k)&#123; space[k] = space[0].cur;//把原来第一位指向的下标赋给新第一位 space[0].cur = k;//要删除的分量赋给第一个元素cur&#125; 静态链表也就是相应其他操作的相关实现。比如ListLength12345678910111213//初始条件:静态链表L已存在。操作结果:返回L中数据元素个数int ListLength(StaticLinkList L)&#123; int j = 0; int i = L[MAXSIZE - 1].cur; while(i) &#123; i = L[i].cur; j++; &#125; return j;&#125;1 3.静态链表优缺点优点：在插入和删除操作时，只要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 缺点：①没有解决连续存储分配带来表长难以确定的问题 ②失去了顺序存储结构随机存储的特性 十二、循环链表对于单个链表，由于每个结点只存储了向后的指针，到了尾标志就停止了向后链的操作，这样当中某一结点就无法找到它的前驱结点了。 将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环， 这种头尾相接的单链表称为单循环链表，简称循环链表。 循环链表解决了一个很麻烦的问题，如何从当中一个结点出发，访问到链表的全部结点。 循环链表和单链表的主要差异就是在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。 十三、双向链表在单链表中，有了next指针，这就使得我们要查找下一结点的事件复杂度为O(1)。可是如果我们要查找的是上一节点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历寻找。 为了克服单向性这一缺点，设计出了双向链表。双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，一个指向直接前驱。1234567//线性表的双向链表存储结构typedef struct DulNode&#123; ElemType data; struct DuLNode *prior;//直接前驱指针 struct DuLNode *next;//直接后继指针&#125;DulNode,*DuLinkList; 既然单链表可以有循环，那么双向链表当然可以是循环表。 由于是双向链表，对于链表中某一结点p，它的后继的前驱是它自己。它的前驱的后继自然也是它自己。即：1p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next 插入操作时，其实并不复杂，但是顺序很重要。 假设存储元素e的结点为s，要实现将结点s插入到p和p-&gt;next之间需要下面几部。1234s-&gt;prior = p;//把p赋给s的前驱s-&gt;next = p-&gt;next;//把p-&gt;next赋给s的后继p-&gt;next-&gt;prior = s;//把s赋给p-&gt;next的前驱p-&gt;next = s;//把s赋给p的后继 如要删除结点p，只要下面两步骤。123p-&gt;prior-&gt;next = p-&gt;next;//把p-&gt;next赋给p-&gt;prior的后继p-&gt;next-&gt;prior = p-&gt;prior;//把p-&gt;proir赋给p-&gt;next的前驱free(p);//释放p的空间 双向链表对于单链表来说，要更复杂一些，对于插入和删除时，需要小心。 另外由于它每个结点需要几轮两份指针，所以在空间上是要占用略多一些的。不过由于良好的对称性，使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。 说白了，也就是空间换时间。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度和空间复杂度计算]]></title>
    <url>%2Fyear%2F03%2F18%2F11332%2F</url>
    <content type="text"><![CDATA[通常，对于一个给定的算法，我们要做 两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二步就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。 算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。 一、事后统计的方法 这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。 二、事前分析估算的方法 因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用事前分析估算的方法。 在编写程序前，依据统计方法对算法进行估算。一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素： 1.算法采用的策略、方法；2.编译产生的代码质量； 问题的输入规模； 机器执行指令的速度。 一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。 1、时间复杂度（1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C f(n)。其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n2+n +1) = O (3n2+n+3) = O (7n2 + n) = O ( n2 ) ，一般都只用O(n2)表示就可以了。注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 从图中可见，我们应该尽可能选用多项式阶O(nk)的算法，而不希望用指数阶的算法。 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!) 一般情况下，对一个问题（或一类算法）只需选择一种基本操作来讨论算法的时间复杂度即可，有时也需要同时考虑几种基本操作，甚至可以对不同的操作赋予不同的权值，以反映执行不同操作所需的相对时间，这种做法便于综合比较解决同一问题的两种完全不同的算法。 （3）求解算法的时间复杂度的具体步骤是： ⑴ 找出算法中的基本语句； 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 ⑵ 计算基本语句的执行次数的数量级； 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。 ⑶ 用大Ο记号表示算法的时间性能。 将基本语句执行次数的数量级放入大Ο记号中。 如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：123456[java] view plain copyfor (i=1; i&lt;=n; i++) x++; for (i=1; i&lt;=n; i++) for (j=1; j&lt;=n; j++) x++; 第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。 Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。 一般来说多项式级的复杂度是可以接受的，很多问题都有多项式级的解——也就是说，这样的问题，对于一个规模是n的输入，在n^k的时间内得到结果，称为P问题。有些问题要复杂些，没有多项式时间的解，但是可以在多项式时间里验证某个猜测是不是正确。比如问4294967297是不是质数？如果要直接入手的话，那么要把小于4294967297的平方根的所有素数都拿出来，看看能不能整除。还好欧拉告诉我们，这个数等于641和6700417的乘积，不是素数，很好验证的，顺便麻烦转告费马他的猜想不成立。大数分解、Hamilton回路之类的问题，都是可以多项式时间内验证一个“解”是否正确，这类问题叫做NP问题。 （4）在计算算法时间复杂度时有以下几个简单的程序分析法则:(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间 (2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下”求和法则” 求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n))) 特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n)) (3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间 (4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下”乘法法则” 乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1T2=O(f(n)g(n)) (5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度 另外还有以下2个运算法则:(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数 （5）下面分别对几个常见的时间复杂度进行示例说明：(1)、O(1) Temp=i; i=j; j=temp; 以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 (2)、O(n2) 2.1. 交换i和j的内容12345[java] view plain copysum=0； （一次） for(i=1;i&lt;=n;i++) （n+1次） for(j=1;j&lt;=n;j++) （n2次） sum++； （n2次） 解：因为Θ(2n2+n+1)=n2（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)； 2.2.1234567[java] view plain copyfor (i=1;i&lt;n;i++) &#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) x++; ② &#125; 解： 语句1的频度是n-1 语句2的频度是(n-1)*(2n+1)=2n2-n-1 f(n)=2n2-n-1+(n-1)=2n2-2； 又Θ(2n2-2)=n2 该程序的时间复杂度T(n)=O(n2). 一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 (3)、O(n)123456789[java] view plain copya=0; b=1; ① for (i=1;i&lt;=n;i++) ② &#123; s=a+b; ③ b=a; ④ a=s; ⑤ &#125; 解： 语句1的频度：2, 语句2的频度： n, 语句3的频度： n-1, 语句4的频度：n-1, 语句5的频度：n-1, T(n)=2+n+3(n-1)=4n-1=O(n).(4)、O(log2n)1234[java] view plain copyi=1; ① hile (i&lt;=n) i=i*2; ② 解： 语句1的频度是1, 设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=log2n 取最大值f(n)=log2n, T(n)=O(log2n ) (5)、O(n3)123456789[java] view plain copyfor(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;i;j++) &#123; for(k=0;k&lt;j;k++) x=x+2; &#125; &#125; 解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,…,m-1 , 所以这里最内循环共进行了0+1+…+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+…+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n3). （5）常用的算法的时间复杂度和空间复杂度 一个经验规则：其中c是一个常量，如果一个算法的复杂度为c 、 log2n 、n 、 n*log2n ,那么这个算法时间效率比较高 ，如果是2n ,3n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。 算法时间复杂度分析是一个很重要的问题，任何一个程序员都应该熟练掌握其概念和基本方法，而且要善于从数学层面上探寻其本质，才能准确理解其内涵。 2、算法的空间复杂度 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\”进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。 如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2Fyear%2F03%2F17%2F28074%2F</url>
    <content type="text"><![CDATA[基本概念和术语数据：是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。数据项：是组成数据元素的、有独立含义的、不可分割的最小单位。数据对象：是性质相同的数据元素的集合，是数据的一个子集。 数据结构数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括逻辑结构和存储结构两个层次。逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。存储结构： 数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。顺序存储结构是借助元素在存储器中的相对位置来 表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。链式存储结构：顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。 数据类型和抽象数据类型数据类型是一个值的集合和定义在这个值集上的一组操作的总称。抽象数据类型一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。抽象数据类型的概念与面向对象方法的思想是一致的。抽象数据类型独立于具体实现，将数据和操作封装在一起，使得用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，从而实现了信息隐藏。抽象数据类型相当于在概念层上描述问题，而类相当于在实现层上描述问题。 算法和算法分析算法(Algorithm)是为了解决某些问题而规定的一个有限长的操作序列。一个算法必须满足以下五个重要特性：1.有穷性。2.确定性。3.可行性。4.输入。5.输出。一个算法的优劣应该从以下几方面来评价：1.正确性。2.可读性。3.健壮性。4.高校性。算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐进时间复杂度，T(n)=O(f(n)),它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，简称时间复杂度。 线性表线性表的定义和特点由n(n&gt;=0)个数据特性相同的元素构成的有限序列称为线性表。线性表中元素的个数n(n&gt;=0)定义为线性表的长度，n=0时称为空表。对于非空的线性表或线性结构，其特点是：1.存在唯一的一个被称作“第一个”的数据元素。2.存在唯一的一个被称作“最后一个”的数据元素。3.除第一个之外，结构中的每个数据元素均只有一个前驱。4.除最后一个之外，结构中的每个数据元素均只有一个后继。 线性表的类型定义1234567891011121314151617181920ADT List&#123; 数据对象：D=&#123;ai|ai∈ElemSet,i=1,2...,n.n&gt;=0&#125; 数据关系: R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; 基本操作: InitList(&amp;L) 操作结果:构造一个空的线性表L。 DestroyList(&amp;L) 初始条件：线性表L已存在。 操作结果：销毁线性表L。 ClearList(&amp;L) ListEmpty(L) ListLength(L) GetElem(L,i,&amp;e) LocateElem(L,e) PriorElem(L,cur_e,&amp;pre_e) NestElem(L,cur_e,&amp;next_e) ListInsert(&amp;L,i,e) ListDelete(&amp;L,i) TraverseList(L) &#125;ADT List 线性表的顺序表示和实现线性表的顺序存储表示线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常称这种顺序存储结构的线性表为顺序表。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装TomCat学习JSP]]></title>
    <url>%2Fyear%2F03%2F17%2F33888%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;这学期开了JSP应用教程，昨天上课时需要安装TomCat，但大家安装的都不是很顺利，安装后也会有各种问题，我就帮大家解决了各种问题，在这里记录一下，以后有同学需要的时候可以看一下。 安装JDK，配置java环境JSP，全称Java Server Page ，所以肯定需要Java环境。我安装的是1.8.0_161，不推荐安装最新版的9.0。Linux系统安装JDK可以参考我之前这篇文章，点这里。Windows系统，我习惯安装在C:\Java,默认安装在C:\Program Files\Java,安装在哪里都行，然后一路默认下去，等待安装结束。然后就是配置Java环境。 右击我的电脑属性，高级系统设置，环境变量，点系统变量的新建， 变量名：JAVA_HOME 变量值：是你安装的路径，我的是C:\Java\jdk1.8.0_161,默认的话是 C:\ProgramFiles\Java\jdk1.8.0_161,你可以点击 浏览目录选择。 再修改path 变量，win7可以直接在最前面加上， %JAVA_HOME%\bin;注意在英文输入法下输;,win10需要点新建 ，值也是%JAVA_HOME%\bin;，然后点击上移到第一个，确定。 再新建 classpath ,变量值为.\;%JAVA_HOME%\lib\tiils.jar 然后就确定、确定、确定。 打开cmd,分别输入java、javac 看是不是分别输出一大长串东西，是的话就是安装好了，如果提示不是内部命令，那就检查一下是不是分号在中文输入法下输入的，win10的path可能会默认加上“ ;”,有的话就删掉。 这样的话就能配置好Java环境了。 安装TomCat 下载TomCat 下载好后一路点下去就能安装好了。 如果你下载的有两个或以上Java版本，在选择Java地址是一定选择你现在配置的那个版本地址，不然会出错。 打开TomCat，在浏览器输入 127.0.0.1:8080 出现TomCat的相关页面就安装好了。 如果操作没有问题，Java路径也没问题，那就卸载后重新装一下。 Linux环境下，创建TomCat文件夹，解压，命令行 12$ cd TomCat/apache-tomcat-8.5.29/bin/$ ./startup.sh 就可以运行 使用时的问题TomCat默认安装在 C:\Program Files\Apache Software Foundation下,找到webapps\Root,这是TomCat的Web服务器的根目录，在里面新建JSP文件，就可以在浏览器中运行了。但win10下你肯定会发现无法将JSP文件保存在这个目录下，就算保存下来也是TXT格式，不是JSP格式，这是因为win10为了安装问题，默认不能通过修改文件后缀名来修改文件格式，解决这个问题可以将下图中的文件扩展名打上勾。然后就解决了。如果运行时再提示有问题，那就是你输入格式的错误了，看是不是空格多打或少打了，或者大小写弄错了，自己琢磨一下就能解决了。 有问题的直接评论问我，或者给我发邮件。大早上起床写教程，好累啊。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>TomCat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Looking up at the stars]]></title>
    <url>%2Fyear%2F03%2F14%2F29068%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim精简版教程]]></title>
    <url>%2Fyear%2F03%2F13%2F12935%2F</url>
    <content type="text"><![CDATA[编辑器的分类 文本编辑器，ASCII码 字处理器：word全称 vi：Visual interface vim: Visual interface improved分类 全屏编辑器, vimEmacsnotepad++… 模式编辑器 grepsedawk vim模式：1.编辑模式（命令模式）2.输入模式3.末行模式4.可视化模式（块）默认处于编辑模式模式转换编辑模式（命令模式） —&gt;&gt;输入模式i：在当前光标所在字符的的前面，转换为输入 a：在当前光标所在字符的的后面，转换为输入 o:在当前光标所在字符的行下方，新建一行，并转为输入模式。 I:在当前光标所在行的行首，转为输入模式 A:在当前光标所在行的行尾，转为输入模式 O:在当前光标所在行的上方，新建一行，并转为输入模式。输入模式—&gt;编辑模式（命令模式)ESC键编辑模式（命令模式）—-&gt;&gt;末行模式:10d10,20dset nu!ls /etc末行模式—-&gt;&gt; 编辑模式（命令模式）ESC ESC键一.打开文件：vim filenamevim /path/to/somefilevim +12 file ：打开文件，光标在12行vim +# file :打开文件，光标在N行vim + file：打开文件，光标在最后一行。vim +/pattern file ：打开文件，光标在第一个匹配的行首二.关闭文件：1.末行模式关闭文件:q 退出:q!:wq 保存退出；w 保存：w! 强制保存:wq –&gt; :x 2.编辑模式（命令模式）ZZ:保存退出 三.移动光标（编辑模式）1.逐字符移动： h:向右 j:向下 k:向上 l:向左 数字h 5h：向右移动5个字符 2.逐个单词移动 w:移动到下一个单词词首 e：跳到当前单词或下一单词的词尾 b：跳到当前单词或前一单词的词首 #w：一次跳n个单词。 4b: 行内跳转0：跳到行首(绝对行首)^:行首的第一个非空白字符$:绝对行尾4.行间跳转#G：跳转到n行G：最后一行GG：第一行 末行模式 ：# 移动到n行 四、翻屏编辑模式（命令模式）f： 向后翻一屏、CTRL+b:向上翻一屏 Ctrl+d： 向下翻半屏Ctrl+u:向上翻半屏 五、删除单个字符x：删除光标所在处的单个字符 #x:删除光标所在处及向后n个字符 六、删除命令：dd命令跟跳转命令组合使用dw：3dw： #de，#dbdd：删除当前光标所在行 #dd：删除当前光标所在行及下面共#行 末行模式下startadd，Endaddd1,8d.,5+d.:表示当前行$:表示最后一行+#：向下#行1,$-3d: 最后一次删除的内容，可以粘贴到别处 七、粘贴命令pp:如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；P:如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面； 八、复制命令 yyy：一行 #y： 九、先删除内容，在转换为输入模式(修改)c：同d命令c$:cc:5C: 十、替换r:替换单个字符R：进入替换模式 十一、撤销编辑操作：u:撤销前一次的操作： 连续u，撤销此前n次操作3u #u：撤销最近#次操作 十二、撤销上一次的撤销Ctrl+r恢复 十三、重复前一次编辑操作. 十四、可视化模式v：按字符选取V：按矩形选取Ctrl+v: 十五、查找/pattern?patternnN 十六、查找并替换在末行模式下 用法和sed一样 address1，address2s/pattern/string/gi 1，$ %:表示全文。 十七、打开多个文件vim file1 file2;next 切换至下一个文件：prev 切换至前一个文件：last 切换至最后一个文件：first 切换最前面的一个文件退出：qall 全部退出 十八：分屏显示一个文件ctrl+w ,s:水平分割窗口ctrl+w,v:垂直分割窗口 在窗口间切换光标Ctrl+w，ARRON ：qa 关闭所有窗口 十九、分窗口多个文件vim -o file1 file2 file3 ..水平分割窗口vim -O file1 file3 …. 垂直分割窗口 二十、将当前文件部分内容另存为另一文件末行模式下使用w命令：w：add1,addr2w /path/to/somewhere 二十一、将另一个文件的内容填充在当前文件中：r /path/to/somefile 二十二、跟shell交互：!command 二十三、高级话题1.显示或取消行号：set numberset nu：set nonu2、显示忽略大小写或区分大小写set ignorecaseset ic:set noignorecase:set noic3.设定自动缩进：set autoindent:set noai 4.查找的文本高亮显示或取消：set hlsearch:set nohlsearch 5.语法高亮:syntax on:syntax off 二十四、配置文件/etc/vimrc~/.vimrc(家目录下) 二十五、练习vim的小游戏vimtutorvim -r file总结以上都是我大学的时候，学习的笔记，无意间看到了，发现很多东西都忘记了，现在准备复习一下，分享在这里。下面赠送一个安装vim插件的命令。神器： wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[青春，呼啸而过]]></title>
    <url>%2Fyear%2F03%2F12%2F27979%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; &nbsp;&nbsp;今天不经意间又翻到这篇文章，第一次读是在初三吧，那时候就特别有感触，可能是因为也同样有过这样相似的经历吧。原来的那些人，早已物是人非。 &nbsp;&nbsp; &nbsp;&nbsp; 在教室里我们习惯往窗外看，有一只鸟，从这棵树飞向另一棵树，它自由地去喉叫属于它自己的青春，这些都是窗子内的我最羡慕的事。 —-题记 &nbsp;&nbsp; &nbsp;&nbsp;高四开学的第一个傍晚，原本想放弃一切安心学习的我受不了同学的诱惑而跟他们去踢球。我不知道在这种特殊的时期下踢球是不是一种错误，或许我们选择的是一份自由，而在那次球赛上我认识了他—-老鸟。 &nbsp;&nbsp; &nbsp;&nbsp;我一个“踩单车”便轻松摆脱了老鸟的堵截，一脚抽射，球轻而易举地进了球门外的臭水沟。老鸟伸出姆指说“强”。我问老鸟为什么说我强，我并没有把球踢进去啊？老鸟说是看了我托着一双废品回收店里的托鞋还来踢球，真的是暴强。那天院长在我身边，我拿起他那只断了一半的托鞋扔向老鸟，怒喊道:我乐意。老鸟缩下头躲着，破口大骂，我不知道他骂什么，因为托鞋打到了他的嘴巴。 &nbsp;&nbsp; &nbsp;&nbsp; 院长挡在我们中间，我没跟老鸟打架。后来我跟老鸟还经常在足球场上交流，但彼此都很鄙视对方，直到高四上学期快结束的某一个晚上，我们几个人都没去上晚自习，踢完球后直接回宿舍洗澡间老鸟则跑到厕所里抽烟，我真的不明白老鸟为什么总躲在厕所里抽烟，随口问他难道单纯地只是不让老师看到吗。 &nbsp;&nbsp; &nbsp;&nbsp;最后老鸟才告诉我，别以为厕所是最臭、最恶心的地方，其实厕所是校园唯一安静的地方。这里不用去想那些矛盾的事情，而且可以把所有的烦恼都排泄到这里，静静地，一个人抽烟，人们总在这里留下什么，却又无法带走。 &nbsp;&nbsp; &nbsp;&nbsp;那晚，厕所里的灯光昏黄昏黄的，我也喜欢上了呆在厕所里抽烟。老鸟跟我说他除了足球也喜欢摇滚，喜欢汪峰，我没想到我可以和老鸟同穿一条裤子，更无法猜测喜欢摇滚的人的疯狂外表下其实是一颗坦诚的心。后来我跟老鸟唱完了汪峰的《笑着哭》后，老鸟头一次没装逼，对我说：我当你是兄弟…… &nbsp;&nbsp; &nbsp;&nbsp;有时候听着摇滚就会忘记老鸟的爱情悲剧史，醒来的时候模糊记得老鸟那个时候整天拿着我的《围城》，而且动不动就说：对丑女细看是种残忍。 &nbsp;&nbsp; &nbsp;&nbsp;“对丑女细看是种残忍”这句话的直接受害者就是我们的校花。老鸟每次见到她就损她几句，本以为校花会恨透老鸟，给我们这些渴望“脱光”者（摆脱光棍）一个机会，没想到那天我硬着头皮向老鸟要回《围城》的时候，老鸟竟公布校花成了他的女朋友。 &nbsp;&nbsp; &nbsp;&nbsp;我说，不会吧，你这屎克螂也有人要，快说，你是用多少金币收买人家的。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟说，有钱我就买泡面了，是她主动写情书给我的。这仿佛告诉我拉登就藏在他家一样。最后老鸟瞪了我一眼笑着说，随便玩玩而已，我不会动真格的，随后便去跟校花约会了。我骂道，你他妈的老鸟，你不要也不给我机会啊…… &nbsp;&nbsp; &nbsp;&nbsp;到了高四下学期，我跟老鸟算是成了真正的兄弟。除了足球、摇滚外，老鸟不断地向我炫耀他那无法验证的爱情史。 &nbsp;&nbsp; &nbsp;&nbsp;他时不时地叼着一支七匹狼的烟，看起来蛮帅的样子，随后他又开谈他跟校花过家家式的爱情剧，他总是说他毫不在意校花：“她的一举一动在我心里好像蜻蜓点水一样，即使泛起一丝波澜最后也归于平静。” &nbsp;&nbsp; &nbsp;&nbsp;可事实是：那天中午校花跑到男生宿舍哭，宿管人员十分无奈，找到老鸟并且对他说：“你拉屎还让我帮你擦屁股啊。”老鸟马上跑过来对我说，这搞的他十分惭愧，真想当场挖个洞把自己埋了。 &nbsp;&nbsp; &nbsp;&nbsp;爱情剧演到最后的时候，校花在班上号啕大哭，老鸟又坐到我旁边对我说：“我真的是无地自容，这真的是扒光我的衣服然后把我放到讲台上。” &nbsp;&nbsp; &nbsp;&nbsp;到了晚上，老鸟约大家去KTV，我们一如既往地点了摇滚歌曲《无地自容》，我不知道我们为什么老是点这首歌，我们这帮人还是老鸟、院长、俊、阿元、我，始终没变过，也没想过要变。 &nbsp;&nbsp; &nbsp;&nbsp;鬼哭狼嚎完后，老鸟说他们分手了。 &nbsp;&nbsp; &nbsp;&nbsp; 我说好啊，失恋也别太伤心，被抛弃后还是男人。 &nbsp;&nbsp; &nbsp;&nbsp; 老鸟没砍我，而是跟我拼酒。当然啦，我肯定敌不过她，不过喝到一半他就哭了，他不会转过头去，是那么坦然，任眼泪流淌。 &nbsp;&nbsp; &nbsp;&nbsp; 之后发生了什么我基本想不起来了，我模糊记得在宿舍里我吐得一塌糊涂时老鸟递给我毛巾和水。可从那以后，我们没再去那家菜给得不是很多的KTV，因为我们成长在这个残酷的时期。 &nbsp;&nbsp; &nbsp;&nbsp;高考结束后我们到离家很远的一个包装工厂里打工，之所以选择在这个破烂的地方是因为这里离家很远，远的忘记了高考。 &nbsp;&nbsp; &nbsp;&nbsp;还是原班人马，我们这几个曾经在晚自习上吼叫《无地自容》，每天踢球踢得很晚，跑回宿舍呆在厕所里抽烟的这帮家伙。但是这里我们告别了足球、告别了摇滚，因为我们已经经历了两次高考。 &nbsp;&nbsp; &nbsp;&nbsp; 单调而劳累的工作后，我们疲倦地躺在杂乱的宿舍里。老鸟说他真想K歌，他怀念高四的残忍与痛快。我看了他一眼，太多的心事其实不必说出口，因为我们彼此明白，我想老鸟是累了，不光是工作么累，每个高考失败的学子都会回想属于他的那一段忧伤，这里不曾有爱情，只有友谊与珍惜……我们轻轻地唱着汪峰的《美丽世界的孤儿》，我们都哭了，不知道为什么，可能我们早已被世人遗忘，只是这个美丽世界的孤儿。 &nbsp;&nbsp; &nbsp;&nbsp; 生活总是太无聊，特别是在这个高考后的日子里。但是老鸟还是会寻找属于自己的快乐，除了老鼠和蟑螂，包装厂里不缺的就是废纸和胶带，于是老鸟用胶带包起一大摞废纸便产生了世界上最原始的足球，而厂房便是我们的足球场，任何时候都是比赛时间，这些仅仅是老鸟和我遗忘世界的方式。 &nbsp;&nbsp; &nbsp;&nbsp;不过这个伟大的发明在工厂里的玻璃碎后被老板扼杀了，老鸟并没有生气，如果在以往他肯定会跟老板大干一场，可是今天他只是异常失落，或许他的心早已疲惫。 &nbsp;&nbsp; &nbsp;&nbsp;在宿舍里，我安慰老鸟说：“没事，心在足球就在，自由不需要方式。” &nbsp;&nbsp; &nbsp;&nbsp;老鸟头一次点了点头，真的像一只受伤的鸟儿。“我想她了。”他一头扎进我的怀中。 &nbsp;&nbsp; &nbsp;&nbsp;我叹了叹气，我想就我知道他是一个受伤的孩子，他是真心对她的，但是他不会说出口，哪怕到最后分手，哪怕自己受伤，永远不会，他是一个任性的孩子。 &nbsp;&nbsp; &nbsp;&nbsp; “我心很痛，很痛。”老鸟哭了，头一次他自己哭我没陪他，因为这是属于他自己的故事…… &nbsp;&nbsp; &nbsp;&nbsp; 我跑到楼下买了一个二手的低音炮，插上MP3。“想唱点什么歌？”我笑着问。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟掀开头上的被子，无奈地笑着说：“《谁伴我闯荡》。” &nbsp;&nbsp; &nbsp;&nbsp;“前面是哪方/谁伴我闯荡/前路没有指引/若我走上又是窄巷/寻梦像扑火/谁共我疯狂……”低音炮的声音很小，但是我们依旧喉破了喉咙，其实歌声响起的时候世界很安静，老鸟和我都在宁静中流下了寂寞的泪水。 &nbsp;&nbsp; &nbsp;&nbsp; 8月，我们还在工厂里打工，录取结果下来了，我们这群经历过两次高考的孩子竟然异常冲动与恐惧。一大早老鸟就约我去网吧，但是他还说：“你先查吧，我再也经不起打击了。” &nbsp;&nbsp; &nbsp;&nbsp; …… &nbsp;&nbsp; &nbsp;&nbsp; 我被北方一所本科高校录取，专业是我向往的中文系。老鸟说，跑那么远干吗，看来你是没有福气跟我踢球、摇滚了，很不幸啊。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟没有告诉我他的录取结果，只是在我要去上大学的前一个晚上老鸟来送我。 &nbsp;&nbsp; &nbsp;&nbsp; 那晚，老鸟仅仅是穿着一件陈旧的牛仔裤和褶皱的衬衣。突然觉得他的衬衣像是我们过去的回忆，所有无法留住的点滴都将折叠起来。今人兴奋的是老鸟终于背起了吉他。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟笑了笑，他的脸异常干燥，像是野地。“怎么样，我比你早学会了吉他，不用低音炮我也可以自己摇滚了。” &nbsp;&nbsp; &nbsp;&nbsp;我竟有一种说不出的感动，却忘记了我们即将告别，就像今晚的月色，是如此朦胧，如此凄美，引人入醉，醒来却是无限的疼痛。“来首什么歌曲呢？” &nbsp;&nbsp; &nbsp;&nbsp;老鸟很霸道地说：“丫的，你懂个屁，这次我自己弹唱。”他接着说：“只送给你的，一个人。” &nbsp;&nbsp; &nbsp;&nbsp;我没有反驳他，或许在他面前我已经失去了反驳的力量，只要期待着他这个无法结束的故事。 &nbsp;&nbsp; &nbsp;&nbsp; 是达达乐队的《南方》，听到旋律我就知道了，突然发现老鸟的声音很有磁性，仿佛回到高四的教室，那里有排得长长的书;我们躲在厕所里抽烟，哭着唱完了汪峰的歌曲;我们一起在KTV里吼歌，等喉咙快吼破的时候我们一起拼酒;在宿舍吐得一踏糊涂的时候老鸟给我递来热水和毛巾……这些陈旧的往事都将折叠在老鸟褶皱的衬衣上，借着凄凉的月光，竟是如此忧伤，我哭了…… &nbsp;&nbsp; &nbsp;&nbsp;“那里总是很潮湿/那里总是很松软/那里总是很多琐碎事/那里总是红和蓝/就这样一天天浪漫/就这样一天天感叹……南方……”老鸟唱着唱着也哭了，我没有问老鸟将要何去何从，他也只是说了声珍重就离开了。那晚老鸟背着吉他，背着他的摇滚梦离开了，我也离开了南方，可至今依旧感伤…… &nbsp;&nbsp; &nbsp;&nbsp; 我真的摸不清这个故事，我也没法去扮演这个角色了。老鸟离开的时候我仿佛发觉：现实总是背叛想象的。一切就像老鸟的高四，面对着残忍却去选择另一种痛苦，他是被青春遗忘的孤儿，拥有遥不可及的梦，或许，青春的我们都失去了年少的背影。 &nbsp;&nbsp; &nbsp;&nbsp; 之后大学的某个早上，我背起吉他的某个早上，我听到有人在弹唱《南方》:“我第一次恋爱在那里/不知她现在怎么样/我家门前的湖边/这时谁还在流连/时间过得飞快/转眼这些已成回忆/每天都有新的问题/不知何时又会再忆起……” &nbsp;&nbsp; &nbsp;&nbsp;这声音再熟悉不过了，我的眼泪突然哗哗流下，不顾一切跑了过去……]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库原理笔记]]></title>
    <url>%2Fyear%2F03%2F11%2F43793%2F</url>
    <content type="text"><![CDATA[一、概论数据库系统的核心任务是数据处理。数据和信息是数据处理中的两个基本概念。数据是信息的一种表现形式，数据通过能书写的信息编码表示信息。数据管理发展的三个阶段：1.人工管理阶段。2.文件管理阶段。3.数据库管理阶段.数据库系统(DataBase Systems, DBS)是为适应数据处理需要而发展起来的一种较为理想数据处理的核心机构。数据库（DataBase，DB）是指长期存储在计算机内、有组织的、统一管理的相关数据的集合。数据库中存储数据具有“集成的”和“共享的”的特点。数据库管理系统(DataBase Management System, DBMS)为用户或应用程序提供访问数据库的方法，包括数据库的建立、查询、更新及各种数据控制。数据库管理系统的主要功能有以下五个方面：1.数据库的定义功能。2.数据库的操纵功能。3.数据库的保护功能。4.数据库的维护功能。5.数据字典(数据库系统中存放三级结构定义的数据库称为数据字典）。 数据库系统结构为了有效组织、管理数据，提高数据库的逻辑独立性和物理独立性，美国国家标准协会为数据库设计了一个严密的三级模式体系结构,它包括外模式、概念模式和内模式。外模式：外模式又称为子模式或用户模式，是用户与数据库系统的接口，是用户能够看见和使用的局部数据逻辑结构和特征的描述。一个数据库可以有多个外模式。不同需求，外模式描述就不相同。概念模式：概念模式又称为模式或逻辑模式，是数据库中全部数据逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式，通常一某种数据模型为基础，综合考虑所有用户的需求，并将这些需求有机的结合成一个逻辑整体。内模式：内模式也称为存储模式或物理模式，是对数据物理结构和存储方式的描述，是数据在数据库内部的表示方式，一个数据库只有一个内模式。内模式是数据库最低一级的逻辑描述，它定义所有内部数据类型、索引和文件的组织方式，以及数据控制等方面的细节。两级映像：为了能够实现数据库三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两级映像。外模式/概念模式映像：对于每一个外模式，数据库系统都有一个外模式/概念模式映像，它定义了该外模式与概念模式之间的对应关系。当概念模式改变时，只需要数据库管理员对各个外模式/概念模式映像做相应的改变，就可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序可以不必修改，保证了数据与程序的逻辑独立性。概念模式/内模式映像：该影响是唯一的，它定义了数据库的全局逻辑结构与存储结构之间的对应关系。当数据库的存储结构发生改变时，只需数据库管理员对概念模式/内模式映射做相应的改变，就可以使概念模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性。外模式/概念模式映像一般在外模式中描述，概念模式/内模式映像一般在内模式中描述。 数据模型数据模型（data model)包括数据库数据的结构部分、操作部分和约束条件，它是研究数据库技术的核心和基础。数据处理的三个阶段1.概念模型:也称信息模型，是对现实世界的认识和抽象描述，按用户的观点对数据和信息进行建模。E-R模型是现实世界到数据世界的一个中间层，表示实体及实体间的联系。涉及的基本术语有：1.实体。2.实体集。3.属性。4.实体标识符。 二元关系主要有以下三种情况：1.一对一联系。2.一对多联系。3.多对多联系。在E-R图中用矩形表示现实世界中的实体，用椭圆形表示实体的属性，用菱形表示实体间的联系。2.逻辑模型:逻辑模型是对应于数据世界的模型，是数据库中实体及其联系的抽象描述。传统的逻辑模型有层次模型、网状模型和关系模型三种，非传统的逻辑模型有面向对象模型。逻辑模型中的数据描述有1.字段（标记实体属性的命名单位称为字段）：字段的命名往往和属性名相同。2.记录，字段的有序集合称为记录。3.文件：同一类记录的集合称为文件。4.关键码：能唯一标识文件中每个记录的字段或字段集，称为记录的关键码（简称为键）。3.物理模型，用于描述数据在物理存储介质上的组织结构，与具体的数据库管理系统、操作系统和计算机硬件都有关系。从概念模型到逻辑模型的转换是由数据库设计人员完成的，从逻辑模型到物理模型的转换是由数据库管理系统完成的，一般人员不必考虑物理实现的细节。常见的数据模型：1.层次模型。2.网状模型。3.关系模型。4.面向对象模型。 二、关系型数据库基本理论关系数据模型关系数据结构1.关系模式：每个关系都有一个模式，称为关系模式，由一个关系名及它的所有属性名构成。如关系模式R(A,B,C),也称关系R或关系模式R。关系中属性个数称为“元数”(arity),元组个数称为“基数”(cardinality).在关系模型中，字段称为属性，字段值称为属性值，记录类型称为关系模式。记录称为元组，元组的集合称为关系或实例。一般用前面的大写英语字母A、B、C…表示单个属性，用后面的大写字母W、X、Y、Z表示属性集，用小写字母表示属性值。元组为行，属性为列。关系中每一个属性都有一个取值范围，称为属性的域(domain)。属性A的域用DOM(A)表示。关系具有以下特点：1.关系（表）可以看成是由元组（行）和属性（列）组成的二维表格。它表示一个实体的集合。2.2.表中一行称为一个元组，可用来表示实体集中一个具体的实体。3.表中的列称为属性，给每一列起一个名称即属性名，表中的属性名不能相同。4.列的取值范围称为域，同列具有相同的域，不同列可以有相同域。5.表中任意两个元组（行）不能相同。2.键(key)在关系型数据库中，键也称为码或关键字，它同常由一个或几个属性组成，能唯一地表示一个元组。超键：在一个关系中，能唯一标识元组的属性或属性组称为关系的超键。候选键：如果一个属性组能唯一标识元组，且又不含有多余的属性，那么这个属性组称为关系的候选键。主键(PK)：如果一个关系中有多个候选键，选其中的一个候选键为关系的主键。外键（FK）：若一个关系R中包含有另一个关系S的主键所对应的属性组F，则称F为R的外键。并称关系S为参照关系，关系R为依赖关系。例如：学生关系和学院关系分别为：学生(SNO,SNAME,SEX,AGE,SDNO)学院(SDNO,SDNAME,CHAIR)学生关系的主键为SNO，学院关系的主键为SDNO，在学生关系中，SDNO是他的外键。更确切的说，SDNO是学院表的主键，将它作为外键放在学生表中，实现两个表之间的联系。我们约定，在主键的属性下面加下划线，在外键的属性下面加波浪线。3.关系模式、关系子模式和存储模式关系模型基本上遵循数据库的三级体系结构。在关系模型中，概念模式是关系模式的集合，外模式是关系子模式的集合，内模式是存储模式的集合。1）关系模式， 是对关系的描述，严格来讲，除了应该包含模式名以及组成该关系的诸属性名以外，还应该包含值域名和模式的主键。一个具体的关系称为一个实例。2）关系子模式，有时，用户使用的数据不直接来自一个关系模式中的数据，而是通过外键连接从若干关系模式中抽取满足一定条件的数据，这种结构可用关系子模式实现。关系子模式是用户所需数据结构的描述，其中包括这些数据来自哪些模式和应满足哪些条件。3）存储模式 描述了关系是如何在物理存储设备上存储的。关系存储的基本组织方式是文件。 关系运算关系运算的特点是集合运算模式，即运算的对象和结果都是集合。关系模型中常用的关系运算包括查询(query)、插入(insert)、删除(delete)、更新(update)。查询运算又可以分为选择、投影、连接、除、并、差、交、笛卡儿积等。其中选择、投影、并、差、笛卡儿积是五种基本运算。 关系的完整性约束1.域完整性约束：关系中属性A的值应该是域DOM(A)中的值，并由语义决定其能否取空值(NULL).2.实体完整性约束：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值。3.参照完整性约束：关系的外键必须是另一个关系主键的有效值或者是空值。需要注意如下两点：1）外键和相应的主键可以不同名，只要定义在相同的域上即可。2）外键的取值是否为空值，应视具体情况而定。如果外键是相应主键的属性，则不允许外键的值为空。4.用户定义完整性约束]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git push失败]]></title>
    <url>%2Fyear%2F03%2F10%2F36673%2F</url>
    <content type="text"><![CDATA[刚才在将本地文件夹上传到github上时出现下面报错12$ git push -u origin masterfatal: unable to access 'https://github.com/hao14293/blogbackup.git/': gnutls_handshake() failed: Error in the pull function. 解决方法1$ git config --global credential.helper store 然后再次1$ git push -u origin master 输入Username Password就完美解决了。]]></content>
      <categories>
        <category>Git and Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[玩转运动世界校园]]></title>
    <url>%2Fyear%2F03%2F10%2F29072%2F</url>
    <content type="text"><![CDATA[本来今天打算写个刷运动世界校园的教程，结果一大早起来发现，用模拟器刷的方法炸了，弄了半天也没解决，这篇文章先放这里，等有方法了再写。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装Eclipse]]></title>
    <url>%2Fyear%2F03%2F10%2F47249%2F</url>
    <content type="text"><![CDATA[配置 java 环境 官方下载jdk(我安装的是jdk1.8.0_161) 创建安装文件夹（我的是 /opt/java)sudo mkdir /opt/java 把下载下来的jdk-8u161-linux-x64.tar.gz 移到 /opt/java 并解压sudo mv /下载/jdk-8u161-linux-x64.tar.gz /opt/java sudo tar -zxvf jdk-8u161-linux-x64.tar.gz 配置环境变量sudo gedit /etc/environment 末尾加入以下配置（JAVA_HOME后的路径就是你jdk的文件位置） PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin" export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/opt/java/jdk1.8.0_161 修改完后保存关闭，输入下面命令使环境变量生效 source /etc/environment 但这个时候输入java -version发现是下面这样$ java -version程序 ‘java’ 已包含在下列软件包中： default-jre gcj-5-jre-headless openjdk-8-jre-headless gcj-4.8-jre-headless gcj-4.9-jre-headless openjdk-9-jre-headless请尝试：sudo apt install &lt;选定的软件包&gt;这是因为Ubuntu默认安装的有java环境，需要我们再配置以下 sudo update-alternatives –install /usr/bin/java java /opt/java/jdk1.8.0_161/bin/java 300 sudo update-alternatives –install /usr/bin/javac javac /opt/java/jdk1.8.0_161/bin/javac 300 sudo update-alternatives –install /usr/bin/jar jar /opt/java/jdk1.8.0_161/bin/jar 300 sudo update-alternatives –install /usr/bin/javah javah /opt/java/jdk1.8.0_161/bin/javah 300 sudo update-alternatives –install /usr/bin/javap javap /opt/java/jdk1.8.0_161/bin/javap 300 上面命令把每条后半部分地址改为你的jdk地址，/opt/java是我的地址。最后执行这条命令使之生效sudo update-alternatives –config java这个时候再执行java -version javac -version$ java -versionjava version “1.8.0_161”Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)$ javac -versionjavac 1.8.0_161这样就大功告成。 安装 Eclipse 官方下载 解压（我是单独创建了个eclipse文件夹）cd 下载/ sudo mv eclipse-inst-linux64.tar.gz /eclipse tar -zxvf eclipse-inst-linux64.tar.gz 进入文件夹双击eclipse-inst,然后就安装吧。（耐心） 创建快捷方式[Desktop Entry]Encoding=UTF-8Name=EclipseComment=EclipseExec=/home/ubuntu/eclipse/jee-oxygen/eclipse/eclipseIcon=/home/ubuntu/eclipse/jee-oxygen/eclipse/icon.xpmTerminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development;ExecIcon改成你的地址。对该文件进行赋权chmod u+x /usr/share/applications/Eclipse.desktop大功告成。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 基础教程]]></title>
    <url>%2Fyear%2F03%2F09%2F46251%2F</url>
    <content type="text"><![CDATA[Git 和 Github是同学们经常使用的工具，这里简单写个基础操作教程。 安装GitUbuntu sudo apt-get install git-core Mac OS X如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ Windows在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name "Your Name" $ git config --global user.email "email@example.com" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： mkdir learngit cd learngit pwd /home/ubuntu/learngit pwd命令用于显示当前目录。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： git init 初始化空的 Git 仓库于 /home/ubuntu/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可. 现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m "wrote a readme file" [master （根提交） a6ee6ed] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m "xxx"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m "add 3 files." 时光机穿梭 我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status 位于分支 master 尚未暂存以备提交的变更： （使用 "git add ..." 更新要提交的内容） （使用 "git checkout -- ..." 丢弃工作区的改动） 修改： readme.txt 修改尚未加入提交（使用 "git add" 和/或 "git commit -a"） git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status 位于分支 master 要提交的变更： （使用 "git reset HEAD ..." 以取消暂存） 修改： readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m "add distributed" [master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status 位于分支 master 无文件要提交，干净的工作区 Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 版本回退 git log命令可以查看历史记录 $ git log commit 4e77f2f8aada37a56fda295813a8b40847933dae Author: hao14293 Date: Thu Mar 8 13:07:05 2018 +0800 add commit a6ee6ed74739651569179c5aadc961a2b548a2a9 Author: hao14293 Date: Thu Mar 8 12:54:56 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline 4e77f2f8aada37a56fda295813a8b40847933dae add a6ee6ed74739651569179c5aadc961a2b548a2a9 wrote a readme file 需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 现在我们准备退回上一个版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 现在我们把当前版本回退到上一版本,就可以使用git reset命令： $ git reset --hard HEAD^ HEAD 现在位于 a6ee6ed wrote a readme file --hard参数有啥意义？这个后面再讲，现在你先放心使用. 打开readme.txt，已经回到上一个版本了。 工作区、暂存区和版本库 我们先来理解下Git 工作区、暂存区和版本库概念 * 工作区：就是你在电脑里能看到的目录。 * 暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 * 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： ![1.jpg](https://i.loli.net/2018/03/08/5aa0d97ba6186.jpg) 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status 位于分支 master 尚未暂存以备提交的变更： （使用 "git add ..." 更新要提交的内容） （使用 "git checkout -- ..." 丢弃工作区的改动） 修改： readme.txt 未跟踪的文件: （使用 "git add ..." 以包含要提交的内容） LICENSE 修改尚未加入提交（使用 "git add" 和/或 "git commit -a"） Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status 位于分支 master 要提交的变更： （使用 "git reset HEAD ..." 以取消暂存） 新文件： LICENSE 修改： readme.txt 现在，暂存区的状态就变成这样了： ![1.jpeg](https://i.loli.net/2018/03/08/5aa0db74a0056.jpeg) 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m "understand how stage works" [master f9c5b54] understand how stage works 2 files changed, 4 insertions(+), 2 deletions(-) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status 位于分支 master 无文件要提交，干净的工作区 现在版本库变成了这样，暂存区就没有任何内容了： ![2.jpeg](https://i.loli.net/2018/03/08/5aa0dbfc271a4.jpeg) Git 基本操作 * git init: 用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。在目录中执行 git init，就可以创建一个 Git 仓库了。 * git clone: 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 执行命令： git clone [url] [url] 为你想要复制的项目，就可以了。 * git add: git add 命令可将该文件添加到缓存 * git status: git status 以查看在你上次提交之后是否有修改。 * git diff: 执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 * * 尚未缓存的改动：git diff * * 查看已缓存的改动： git diff --cached * * 查看已缓存的与未缓存的所有改动：git diff HEAD * * 显示摘要而非整个 diff：git diff --stat * git commit: 使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 * git reset HEAD: git reset HEAD 命令用于取消已缓存的内容。 * git rm: 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。 * * 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 git rm * * 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f git rm -f * * 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可 git rm --cached 如我们删除 hello.php文件： $ git rm hello.php rm 'hello.php' $ ls README * * 不从工作区中删除文件： $ git rm --cached README rm 'README' $ ls README * * 可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件： git rm –r * 进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。 * git mv: git mv 命令用于移动或重命名一个文件、目录、软连接。 我们先把刚移除的 README 添加回来： $ git add README 然后对其重名: $ git mv README README.md $ ls README.md 远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C "youremail@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 添加远程库 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:hao14293/learngit.git 请千万注意，把上面的hao14293替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -> master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 从远程库克隆 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:hao14293/gitskills.git Cloning into 'gitskills'... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd gitskills $ ls README.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/hao14293/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为"必杀技特性"，而正是因为它，将 Git 从版本控制系统家族里区分出来。 创建分支命令： git branch (branchname) 切换分支命令: git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 列出分支 列出分支基本命令： git branch 没有参数时，git branch 会列出你在本地的分支。 $ git branch * master 此例的意思就是，我们有一个叫做"master"的分支，并且该分支是当前分支。 当你执行 git init 的时候，缺省情况下 Git 就会为你创建"master"分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 $ git branch testing $ git branch * master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了"testing"分支，Git 将还原你的工作目录到你创建分支时候的样子 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ ls README $ echo 'runoob.com' > test.txt $ git add . $ git commit -m 'add test.txt' [master 048598f] add test.txt 2 files changed, 1 insertion(+), 3 deletions(-) delete mode 100644 hello.php create mode 100644 test.txt $ ls README test.txt $ git checkout testing Switched to branch 'testing' $ ls README hello.php 当我们切换到"testing"分支的时候，我们添加的新文件test.txt被移除了, 原来被删除的文件hello.php文件又出现了。切换回"master"分支的时候，它们有重新出现了。 $ git checkout master Switched to branch 'master' $ ls README test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtest Switched to a new branch 'newtest' $ git rm test2.txt rm 'test2.txt' $ ls README test.txt $ git commit -am 'removed test2.txt' [newtest 556f0a0] removed test2.txt 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ git checkout master Switched to branch 'master' $ ls README test.txt test2.txt 如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。 使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。 删除分支 删除分支命令： git branch -d (branchname) 例如我们要删除"testing"分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： git merge $ git branch * master newtest $ ls README test.txt test2.txt $ git merge newtest Updating 2e082b7..556f0a0 Fast-forward test2.txt | 1 - 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ ls README test.txt 以上实例中我们将 newtest 分支合并到主分支去，test2.txt 文件被删除。 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 $ git branch * master $ cat test.txt runoob.com 首先，我们创建一个叫做"change_site"的分支，切换过去，我们将内容改为 www.runoob.com 。 $ git checkout -b change_site Switched to a new branch 'change_site' $ vim test.txt $ head -1 test.txt www.runoob.com $ git commit -am 'changed the site' [change_site d7e7346] changed the site 1 file changed, 1 insertion(+), 1 deletion(-) 将修改的内容提交到 "change_site" 分支中。 现在，假如切换回 "master" 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。 $ git checkout master Switched to branch 'master' $ head -1 test.txt runoob.com $ vim test.txt $ cat test.txt runoob.com 新增加一行 $ git diff diff --git a/test.txt b/test.txt index 704cce7..f84c2a4 100644 --- a/test.txt +++ b/test.txt @@ -1 +1,2 @@ runoob.com +新增加一行 $ git commit -am '新增加一行' [master 14b4dca] 新增加一行 1 file changed, 1 insertion(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 $ vim test.txt $ cat test.txt www.runoob.com 新增加一行 $ git diff diff --cc test.txt index f84c2a4,bccb7c2..0000000 --- a/test.txt +++ b/test.txt @@@ -1,2 -1,1 +1,2 @@@ - runoob.com + www.runoob.com +新增加一行 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU test.txt $ git add test.txt $ git status -s M test.txt $ git commit [master 88afe0e] Merge branch 'change_site' 现在我们成功解决了合并中的冲突，并提交了结果。 标签管理 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 runoob 项目发布一个"1.0"版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）"v1.0"的标签。 -a 选项意为"创建一个带注解的标签"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了： $ git log --oneline --decorate --graph * 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site' |\ | * d7e7346 (change_site) changed the site * | 14b4dca 新增加一行 |/ * 556f0a0 removed test2.txt * 2e082b7 add test2.txt * 048598f add test.txt * 85fc7e7 test comment from runoob.com 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site' |\ | * d7e7346 (change_site) changed the site * | 14b4dca 新增加一行 |/ * 556f0a0 removed test2.txt * 2e082b7 add test2.txt * 048598f add test.txt * 85fc7e7 (tag: v0.9) test comment from runoob.com 如果我们要查看所有标签可以使用以下命令： $ git tag v0.9 v1.0 指定标签信息命令： git tag -a -m "runoob.com标签" PGP签名标签命令： git tag -s -m "runoob.com标签" Github …or create a new repository on the command line echo "# test" >> README.md git init git add README.md git commit -m "first commit" git remote add origin https://github.com/hao14293/test.git git push -u origin master …or push an existing repository from the command line git remote add origin https://github.com/hao14293/test.git git push -u origin master git将本地仓库推送到github 1. 首先在本地创建ssh key; $ ssh-keygen -t rsa -C "your_email@youremail.com" 2. 回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key,title随便填，粘贴key。为了验证是否成功，在Git bash下输入： $ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。 git config –global user.name “your name”git config –global user.email “your_email@youremail.com“ 进入要上传的仓库，添加远程地址： $ git remote add origin git@github.com:yourName/yourRepo.git(可以去git上复制仓库的地址)4.提交、上传 接下来在本地仓库里添加一些文件，比如README， git add README git commit -m “first commit” 上传到github： $ git push origin mastergit push命令会将本地仓库推送到远程服务器。 git pull命令则相反。]]></content>
      <categories>
        <category>Git and Github</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 程序快捷方式创建方法]]></title>
    <url>%2Fyear%2F03%2F09%2F43744%2F</url>
    <content type="text"><![CDATA[方法很简单，下面以创建Eclipse快捷方式为例。其他程序只需把名字改为对应名字就行。 sudo gedit /usr/share/applications/Eclipse.desktop 复制以下代码： [Desktop Entry] Encoding=UTF-8 Name=Eclipse Comment=Eclipse Exec=/home/ubuntu/eclipse/jee-oxygen/eclipse/eclipse Icon=/home/ubuntu/eclipse/jee-oxygen/eclipse/icon.xpm Terminal=false StartupNotify=true Type=Application Categories=Application;Development; 把Exec和Icon改为你的地址。 最后 sudo chmod u+x Eclipse.desktop]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows10环境下装Ubuntu双系统]]></title>
    <url>%2Fyear%2F03%2F08%2F56114%2F</url>
    <content type="text"><![CDATA[很多入门的小伙伴都想体验一下Linux，但又不舍得Windows,所以就想到了装双系统。我刚开始也是这样，大一开始折腾，虽然网上教程很多，但我第一次仔仔细细地按照教程做，最后还是没能成功，还把Windows上资料给弄没了。这两年也装过不少次系统了，所以今天想写一下教程，按照这个教程请放心安装，一定可以成功。 环境/工具 windows10 U盘（大于4G） Ultraiso ubuntu 16.04 LTS (百度云下载) 耐心 方法/步骤一. 制作Ubuntu 16.04启动盘1.插入用来制作启动盘的U盘（会被格式化，请备份好重要文件），打开UltraISO刻录软件（免费无限期试用）。 2.选择“文件(F)”-&gt;“打开”，找到“Ubuntu-16.04-desktop-amd64.iso”镜像文件，然后点击“打开”。3.选择“启动(B)”-&gt;“写入硬盘映像”，打开启动盘制作界面。4.然后点击下方的“写入”，会弹出警告提示，确定后，就会开始制作启动盘。写入完成后关闭UltraISO软件即可。 这样就制作好了启动盘。 二. 为Ubuntu系统分盘在Windows 10中打开“磁盘管理器”，找一个空闲的磁盘分区，压缩出来一部分空间给Ubuntu使用，压缩出来的硬盘应处于未分配状态。或者通过删除某个不使用的本地磁盘使其处于未分配状态。敲黑板:这个可能有人不太理解，其实很简单，如果你只有C盘，右击选择压缩磁盘，大小就是你要分出来的ubuntu系统的大小，想要好好用linux的同学最好分出大于40G。分出来后这部分是黑色的。 三. [BIOS设置]不同电脑进入BIOS方法不同，一般 F2键和 ESC键的比较多，可以试一下，不行的话可以自己百度。1.关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。 2.在BIOS中设置U盘为第一启动项，保存并重启电脑。不知道怎么设置的看这里:上图中的Boot Option #1就是第一启动项，按ENTER键和上下键选择你的U盘启动项后ENTER，然后保存后重启。 四. [安装Ubuntu 16.04 LTS] 这时候开机后会看到Try Ubuntu或者Install Ubuntu,选择Try Ubuntu，也就是第一个，Enter。 稍等一会儿进入UbuntuDesktop。 双击左上角的”Install Ubuntu 16.04LTS“，打开安装界面。（安装过程比较简单，根据提示输入一些信息即可）在左侧语言栏选择安装语言，然后点击“继续”。如果网速比较快，可以勾选“安装Ubuntu时下载更新”。（如果选择的语言是中文，这里在更新的时候会自动安装中文输入法，当然也可以安装完成后安装搜狗拼音输入法Linux版）注意注意，重点来了,一定要选择最后一个其他选项,不要有疑问，为了你的Windows安全。接下来要为Ubuntu系统分区，就像Windows下的C、D、E盘。网上有不同的分法，我的使用经验是分三个就行，分别是/boot、/swap和 /。 /boot我是分1G，swap分5G，剩下的全部分给/。我没截到图，图片是网上找的，就是先点分出来标注空闲的那个分区，然后点左下角+号，/boot /swap / 都是在挂载点里面选择。选择逻辑分区。把三个都分好。特别注意,分好后看最下面的安装启动引导器的设备,我第一次错就是在这里，这个要选择/boot 对应的sda，不然会失败。继续shanghai 继续继续名字、密码配好继续耐心等待可以拔掉U盘了，立即重启。如果此时黑屏的话不要紧张，电源键重启，开机后就会看到选择进入系统界面了，第一个就是Ubuntu系统，第三个是Windows，第二个也是Ubuntu，先不用管。然后，好好折腾你的Ubuntu吧！！！]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码暴力破解 '2018年刑侦科推理试题']]></title>
    <url>%2Fyear%2F03%2F07%2F42008%2F</url>
    <content type="text"><![CDATA[据说是2018年刑侦科推理试题，感受一下。 作为一个学渣，瞅一眼头就晕了，那就按老师说的‘不会的就选Ｃ吧’，不过仔细分析一下这题挺有意思的。 正常推理的话是这个样子： 读题知，第五题为核心题目。先假设第五题为A，则2为C,8为A。由8知，2、5、10与1相邻，则1为B。可知第6题排除A B，可知第9题中x与5答案相同，第9题若选A，则6为A不符合；不选C；若选D，矛盾；故9为B。则10为A。第6题排除D，故6为C。第4题为C。第3题为A。至此，选A有4，选C有3，选B有2，则7为D。证毕。(若第五题不为A，应继续假设为其他项证明之) 最后得出答案 BCACACDABA. 对于我这种脑子笨的人来说，推出来也差不多半个小时了。。。 那这题让程序员来做会怎么样呢？ 上代码。 Python def p0(ans, hypo): return True def p1(ans, hypo): if ans == 'A': return hypo[4] == 'C' if ans == 'B': return hypo[4] == 'D' if ans == 'C': return hypo[4] == 'A' if ans == 'D': return hypo[4] == 'B' return None def p2(ans, hypo): if ans == 'A': return hypo[2] != hypo[5] and hypo[2] != hypo[1] and hypo[2] != hypo[3] if ans == 'B': return hypo[5] != hypo[2] and hypo[5] != hypo[1] and hypo[5] != hypo[3] if ans == 'C': return hypo[1] != hypo[2] and hypo[1] != hypo[5] and hypo[1] != hypo[3] if ans == 'D': return hypo[3] != hypo[2] and hypo[3] != hypo[5] and hypo[3] != hypo[1] return None def p3(ans, hypo): if ans == 'A': return hypo[0] == hypo[4] if ans == 'B': return hypo[1] == hypo[6] if ans == 'C': return hypo[0] == hypo[8] if ans == 'D': return hypo[5] == hypo[9] return None def p4(ans, hypo): if ans == 'A': return hypo[4] == hypo[7] if ans == 'B': return hypo[4] == hypo[1] if ans == 'C': return hypo[4] == hypo[8] if ans == 'D': return hypo[4] == hypo[6] return None def p5(ans, hypo): if ans == 'A': return hypo[7] == hypo[1] and hypo[7] == hypo[3] if ans == 'B': return hypo[7] == hypo[0] and hypo[7] == hypo[5] if ans == 'C': return hypo[7] == hypo[2] and hypo[7] == hypo[9] if ans == 'D': return hypo[7] == hypo[4] and hypo[7] == hypo[8] return None def p6(ans, hypo): na, nb, nc, nd = 0, 0, 0, 0 for x in hypo: if x == 'A': na += 1 if x == 'B': nb += 1 if x == 'C': nc += 1 if x == 'D': nd += 1 min_opt = min(na, nb, nc, nd) if ans == 'A': return nc == min_opt if ans == 'B': return nb == min_opt if ans == 'C': return na == min_opt if ans == 'D': return nd == min_opt return None def p7(ans, hypo): x = ord(hypo[0]) if ans == 'A': return abs(x - ord(hypo[6])) != 1 if ans == 'B': return abs(x - ord(hypo[4])) != 1 if ans == 'C': return abs(x - ord(hypo[1])) != 1 if ans == 'D': return abs(x - ord(hypo[9])) != 1 return None def p8(ans, hypo): a = hypo[0] == hypo[5] if ans == 'A': return a != hypo[5] == hypo[4] if ans == 'B': return a != hypo[9] == hypo[4] if ans == 'C': return a != hypo[1] == hypo[4] if ans == 'D': return a != hypo[8] == hypo[4] return None def p9(ans, hypo): na, nb, nc, nd = 0, 0, 0, 0 for x in hypo: if x == 'A': na += 1 if x == 'B': nb += 1 if x == 'C': nc += 1 if x == 'D': nd += 1 delta = max(na, nb, nc, nd) - min(na, nb, nc, nd) if ans == 'A': return delta == 3 if ans == 'B': return delta == 2 if ans == 'C': return delta == 4 if ans == 'D': return delta == 1 return None def test_hypo(problem_list, hypo): index = 0 for p in problem_list: if not p.__call__(hypo[index], hypo): return False index += 1 return True def hypo_generator(size): num = 1 for x in range(size): num *= 4 hypo = [None] * size for i in xrange(num): for j in range(size): hypo[j] = ['A', 'B', 'C', 'D'][(i >> (j < 1)) & 3] yield hypo def main(): problem_list = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9] for hypo in hypo_generator(len(problem_list)): if test_hypo(problem_list, hypo): print 'Answer:', hypo if __name__ == '__main__': main() 'D'){ return false; } v[i] = c; if (!solve(v, i + 1, 'A') && !solve(v, i, c + 1)) { return false; } const int x = (c - 'A'); switch (i) { case 1: return true; case 2: if (v[5] == "CDAB"[x]) { return true; } break; case 3: { const int w[4] = { 3,6,2,4 }; int j = 0; for (; j < 4; ++j) { if (j != x && v[w[j]] == v[w[x]]) { break; } } if (j >= 4) { return true; } break; } case 4: if (v["1216"[x] - '0'] == v["579:"[x] - '0']) { // '9' + 1 = ':' return true; } break; case 5: if (c == v["8497"[x] - '0']) { return true; } break; case 6: if ((v["2135"[x] - '0'] == v["46:9"[x] - '0']) && (v["2135"[x] - '0'] == v[8])) { return true; } break; case 7: if ("CBAD"[x] - 'A' == stat(v, 'm')) { return true; } break; case 8: if (abs(v["752:"[x] - '0'] - v[1]) > 1) { return true; } break; case 9: if ((v[1] == v[6]) != (v["6:29"[x] - '0'] == v[5])) { return true; } break; case 10: if (("3241"[x] - '0') == stat(v, 'd')) { return true; } break; } return solve(v, i, c + 1); } int main() { const int n = 11; vector v(n); if (solve(v, 1, 'A')) { for (int i = 1; i < n; ++i) { cout < i < ' '; } cout < endl; for (int i = 1; i < n; ++i) { cout < v[i] < ' '; } cout < endl; } }]]></content>
      <categories>
        <category>cool-code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《我》]]></title>
    <url>%2Fyear%2F03%2F02%2F10484%2F</url>
    <content type="text"><![CDATA[我喜欢出发 喜欢离开喜欢一生中都能有新的梦想千山万水 随意行去我喜欢停留 喜欢长久喜欢在园里种下千棵果树期待冬雷夏雨 春华秋实喜欢生命里只有单纯的盼望只有一种安定和缓慢的成长我喜欢岁月漂洗过后的颜色喜欢那没有唱出来的歌我喜欢在夜里写一首长诗然后再来在这清凉的早上逐行逐段地检视慢慢删去每一个与你有着关联的字《我》 － 席慕蓉]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫入门项目]]></title>
    <url>%2Fyear%2F03%2F01%2F33549%2F</url>
    <content type="text"><![CDATA[今天为大家整理了32个Python爬虫项目。 整理的原因是，爬虫入门简单快速，也非常适合新入门的小伙伴培养信心。所有链接指向GitHub，祝大家玩的愉快~ 1、WechatSogou [1]– 微信公众号爬虫。 基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。 github地址：https://github.com/Chyroc/WechatSogou 2、DouBanSpider [2]– 豆瓣读书爬虫。 可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。 github地址：https://github.com/lanbing510/DouBanSpider3、zhihu_spider [3]– 知乎爬虫。 此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用scrapy，数据存储使用mongo github地址：https://github.com/LiuRoy/zhihu_spider 4、bilibili-user [4]– Bilibili用户爬虫。 总数据数：20119918，抓取字段：用户id，昵称，性别，头像，等级，经验值，粉丝数，生日，地址，注册时间，签名，等级与经验值等。抓取之后生成B站用户数据报告。 github地址：https://github.com/airingursb/bilibili-user 5、SinaSpider [5]– 新浪微博爬虫。 主要爬取新浪微博用户的个人信息、微博信息、粉丝和关注。代码获取新浪微博Cookie进行登录，可通过多账号登录来防止新浪的反扒。主要使用 scrapy 爬虫框架。 github地址：https://github.com/LiuXingMing/SinaSpider 6、distribute_crawler [6]– 小说下载分布式爬虫。 使用scrapy,Redis, MongoDB,graphite实现的一个分布式网络爬虫,底层存储MongoDB集群,分布式使用Redis实现,爬虫状态显示使用graphite实现，主要针对一个小说站点。 github地址：https://github.com/gnemoug/distribute_crawler 7、CnkiSpider [7]– 中国知网爬虫。 设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。 github地址：https://github.com/yanzhou/CnkiSpider 8、LianJiaSpider [8]– 链家网爬虫。 爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。 github地址：https://github.com/lanbing510/LianJiaSpider 9、scrapy_jingdong [9]– 京东爬虫。 基于scrapy的京东网站爬虫，保存格式为csv。 github地址：https://github.com/taizilongxu/scrapy_jingdong 10、QQ-Groups-Spider [10]– QQ 群爬虫。 批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。 github地址：https://github.com/caspartse/QQ-Groups-Spider 11、wooyun_public[11]-乌云爬虫。 乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在MongoDB中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。 https://github.com/hanc00l/wooyun_public 12、spider[12]– hao123网站爬虫。 以hao123为入口页面，滚动爬取外链，收集网址，并记录网址上的内链和外链数目，记录title等信息，windows7 32位上测试，目前每24个小时，可收集数据为10万左右 https://github.com/simapple/spider 13、findtrip [13]– 机票爬虫（去哪儿和携程网）。 Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。 https://github.com/fankcoder/findtrip 163spider [14] – 基于requests、MySQLdb、torndb的网易客户端内容爬虫 https://github.com/leyle/163spider doubanspiders[15]– 豆瓣电影、书籍、小组、相册、东西等爬虫集 https://github.com/fanpei91/doubanspiders QQSpider [16]– QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。 https://github.com/LiuXingMing/QQSpider baidu-music-spider [17]– 百度mp3全站爬虫，使用redis支持断点续传。 https://github.com/Shu-Ji/baidu-music-spider tbcrawler[18]– 淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在mongodb。 https://github.com/pakoo/tbcrawler stockholm [19]– 一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。 https://github.com/benitoro/stockholm BaiduyunSpider[20]-百度云盘爬虫。 https://github.com/k1995/BaiduyunSpider Spider[21]-社交数据爬虫。支持微博,知乎,豆瓣。 https://github.com/Qutan/Spider proxy pool[22]-Python爬虫代理IP池(proxy pool)。 https://github.com/jhao104/proxy_pool music-163[23]-爬取网易云音乐所有歌曲的评论。 https://github.com/RitterHou/music-163 jandan_spider[24]-爬取煎蛋妹纸图片。 CnblogsSpider[25]-cnblogs列表页爬虫。 spider_smooc[26]-爬取慕课网视频。 CnkiSpider[27]-中国知网爬虫。 knowsecSpider2[28]-知道创宇爬虫题目。 aiss-spider[29]-爱丝APP图片爬虫。 SinaSpider[30]-动态IP解决新浪的反爬虫机制，快速抓取内容。 csdn-spider[31]-爬取CSDN上的博客文章。 ProxySpider[32]-爬取西刺上的代理IP，并验证代理可用性 作者：一直在水下链接：https://www.jianshu.com/p/39d4b15c05ee來源：简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16道Python经典面试题及答案]]></title>
    <url>%2Fyear%2F02%2F26%2F34102%2F</url>
    <content type="text"><![CDATA[随着Python在企业中的应用越来越多，岗位需求越来越大，面试成为了搞定优质职位的快速方式，下面是笔者面试10余家企业总结的面试题，希望对Python从业者有帮助。 1.Python是如何进行内存管理的？ 答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制 一、对象的引用计数机制Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1，一个对象分配一个新名称 2，将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1，使用del语句对对象别名显示的销毁 2，引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 二、垃圾回收 1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 三、内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 2.什么是lambda函数？它有什么好处? 答：lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数 lambda函数：首要用途是指点短小的回调函数 lambda [arguments]:expression a=lambdax,y:x+y a(3,11) 3.Python里面如何实现tuple和list的转换？ 答：直接使用tuple和list函数就行了，type()可以判断对象的类型 4.请写出一段Python代码实现删除一个list里面的重复元素 答：1,使用set函数，set(list) 2，使用字典函数， =[1,2,4,2,4,5,6,5,7,8,9,0] b={} b=b.fromkeys(a) c=list(b.keys()) c 5.编程用sort进行排序，然后从最后一个元素开始判断 a=[1,2,4,2,4,5,7,10,5,5,7,8,9,0,3] a.sort() last=a[-1] for i inrange(len(a)-2,-1,-1): if last==a[i]: del a[i] else:last=a[i] print(a) 6.Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别） 答：赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。 浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数} 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数} 7.介绍一下except的用法和作用？ 答：try… except… except… [else…] [finally…]执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行如果存在finally语句，最后总是会执行。 8.Python中pass语句的作用是什么？ 答：pass语句不会执行任何操作，一般作为占位符或者创建占位程序，while False: pass 9.介绍一下Python下range()函数的用法？ 答：列出一组数据，经常用在for in range()循环中. 10.如何用Python来进行查询和替换一个文本字符串？ 答：可以使用re模块中的sub()函数或者subn()函数来进行查询和替换，格式： sub(replacement, string[,count=0])（replacement是被替换成的文本，string是需要被替换的文本，count是一个可选参数，指最大被替换的数量） import re p=re.compile(‘blue|white|red’) print(p.sub(‘colour’,’blue socks and red shoes’)) colour socks and colourshoes print(p.sub(‘colour’,’blue socks and red shoes’,count=1)) colour socks and redshoes subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量 11.Python里面match()和search()的区别？ 答：re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。 re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。 print(re.match(‘super’, ‘superstition’).span()) (0, 5) print(re.match(‘super’, ‘insuperable’)) None print(re.search(‘super’, ‘superstition’).span()) (0, 5) print(re.search(‘super’, ‘insuperable’).span()) (2, 7) 12.用Python匹配HTML tag的时候，和有什么区别？ 答：术语叫贪婪匹配( )和非贪婪匹配( )例如: test : test : 13.Python里面如何生成随机数？ 答：random模块随机整数：random.randint(a,b)：返回随机整数x,a&lt;=x&lt;=b random.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。 随机实数：random.random( ):返回0到1之间的浮点数 random.uniform(a,b):返回指定范围内的浮点数。 14.有没有一个工具可以帮助查找python的bug和进行静态的代码分析？ 答：PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告 Pylint是另外一个工具可以进行codingstandard检查 15.如何在一个function里面设置一个全局的变量？ 答：解决方法是在function的开始插入一个global声明： def f(): global x 16.单引号，双引号，三引号的区别 答：单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释 如果要表示Let’s go 这个字符串 单引号：s4 = ‘Let\’s go’ 双引号：s5 = “Let’s go” s6 = ‘I realy like“python”!’ 这就是单引号和双引号都可以表示字符串的原因了作者：地球的外星人君链接：https://zhuanlan.zhihu.com/p/34124369来源：知乎]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法和数据结构 －－ 初等排序]]></title>
    <url>%2Fyear%2F02%2F21%2F19195%2F</url>
    <content type="text"><![CDATA[排序就是将数据按一定顺序重新排列。它是很多算法的基础，可以让数据变得更容易处理。这篇文章会简单地介绍几种排序算法，当然这是初等排序，在效率上会比较差，但实现起来相对容易。 1. 插入排序法插入排序法是一种很容易想到的算法，它的思路与打扑克时排列手牌的方法很相似。 插入排序法的算法如下： insertionSort(A,N) //包含N个元素的0起点数组A for i从１到N-1 v = A[i] j = i - 1 while j &gt;= 0 且 A[j] &gt; v A[j+1] = A[j] j– A[j+1] = v 请编写一个程序，用插入排序法将包含N个元素的数列A按升序排列。为检验算法的执行过程，请输出个计算步骤的数组。 输入 在第１行输入定义数组长度的整数N。在第２行输入N个整数，以空格隔开。 输出 输出总共有N行。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 1000 C #include &lt;stdio.h&gt; /* 按顺序输出数组元素 */ void trace(int A[], int N){ int i; for(i=0;i&lt;N;i++){ if(i&gt;0) printf(&quot; &quot;); /*相邻元素之间输出１个空格 */ printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); } /* 插入排序 */ void insertionSort(int A[], int N){ int j, i, v; for(i=1;i&lt;N;i++){ v = A[i]; j=i-1; while(j&gt;=0 &amp;&amp; A[j]&gt;v){ A[j+1] = A[j]; j--; } A[j+1] = v; trace(A,N); } } int main(){ int N, i, j; int A[100]; scanf(&quot;%d&quot;, &amp;N); for(i=0; i &lt; N; i++) scanf(&quot;%d&quot;, &amp;A[i]); trace(A,N); insertionSort(A,N); return 0; } 2. 冒泡排序法顾名思义，冒泡排序法就是让数组元素像水中的气泡一样逐渐上浮，进而达到排序的目的。下述算法便是利用冒泡排序法将数列排为升序的例子。 bubbleSort(A,N) //包含N个元素的0起点数组A flag = 1 while flag flag = 0 for j从N-1到1 if A[j]&lt;A[j-1] A[j]与A[j-1]交换 flag = 1 请编写一个程序，读取数列A，利用冒泡排序法将其按升序排列并输出。另外请报告冒泡排序法执行元素交换的次数。 输入 在第１行输入定义数组长度的整数N。在第2行输入N个整数，以空格隔开。 输出 总计２行。请在第１行输出排序后的数列。相邻元素以一个空格隔开。第２行输出元素交换的次数。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 100 C++ #include &lt;iostream&gt; using namespace std; //使用flag的冒泡排序法 int bubbleSort(int A[], int N){ int sw = 0; bool flag = 1; for(int i=0; flag; i++){ flag = 0; for(int j= N-1; j&gt;=i+1; j--){ if(A[j] &lt; A[j-1]){ swap(A[j], A[j-1]); flag = 1; sw++; } } } return sw; } int main(){ int A[100], N, sw; cin &gt;&gt; N; for( int i=0; i&lt; N; i++) cin &gt;&gt; A[i]; sw = bubbleSort(A,N); for(int i=0; i &lt; N; i++){ if (i) count &lt;&lt; &quot; &quot;; count &lt;&lt; A[i]; } count &lt;&lt; endl; count &lt;&lt; sw &lt;&lt; endl; return 0; } 3.选择排序法选择排序法是一种非常直观的算法，它会在每个计算步骤中选出一个最小值，进而完成排序。 selectionSort(A,N) for i 从0到N-1 minj = i for j从i到N-1 if A[j] &lt; A[minj] minj = j A[i]与A[min]交换 请编写一个程序，读取数列A，利用选择排序法将其按升序排列并输出。请输出实际运行过程中执行交换操作的次数。 输入 在第１行输入定义数组长度的整数N。在第2行输入N个整数，以空格隔开。 输出 总计２行。请在第１行输出排序后的数列。相邻元素以一个空格隔开。第２行输出元素交换的次数。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 100 C #include &lt;stdio.h&gt; /*选择排序法*/ int selectionSort( int A[], int N){ int i,j, t, sw=0, minj; for(i = 0;i &lt; N-1; i++){ minj = i; for(j = i; j&lt; N; j++) { if(A[j] &lt; A[minj] ) minj = j; } t = A[i]; A[i] = A[minj]; A[minj] = t; if (i != minj) sw++; } return sw; } int main(){ int A[100], N, i, sw; scanf(&quot;%d&quot;, &amp;N); for(i=0; i &lt; N; i++) scanf(&quot;%d&quot;, &amp;A[i]); sw = selectionSort(A,N); for(i = 0; i &lt; N; i++){ if( i &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); printf(&quot;%d\n&quot;, sw); return 0; } 4. 稳定排序所谓稳定排序，是指当数据中存在２个或２个以上键值相等的元素时，这些元素在排序处理前后顺序不变。 现在我们来给扑克牌排序。我们使用的扑克牌包含S,H,C,D的４种花色以及１，２，…,9，的９个数字，总计３６张。例如红桃８记为“H８”，方块１记为“D1”。 请编写一个程序，分别用冒泡排序法和选择排序法对输入的N张扑克牌进行以数字为基准的升序排列。两种算法需各自遵循下述伪代码的描述。下述数组元素皆为0起点。 bubbleSort(C,N) for i = 0 to N-1 for j = N-1 downto i+1 if C[j].value &lt; C[j-1].value C[j] 与 C[j-1]交换 selestionSort(C, N) for i = 0 to N-1 minj = i for j = i to N-1 if C[j].value &lt; C[minj].value minj = j C[i] 与 C[minj] 交换 另外，请报告各算法对于所给输入是否有稳定输出。 输入 在第１行输入扑克牌的张数N. 第２行输入N张扑克牌的数据。每张牌由代表花色和数字的２个字符组成，相邻扑克牌之间用１个空格隔开。 输出 在第一行按顺序输出经冒泡排序法排序后的扑克牌，相邻扑克牌之间用１个空格隔开。 在第２行输出该输出是否稳定。 在第3行按顺序输出经选择排序法排序后的扑克牌，相邻扑克牌之间用１个空格隔开。 在第4行输出该输出是否稳定。 限制 1 =&lt; N =&lt; 36C++ #include &lt;iostream&gt; using namespace std; struct Card{ char suit, value;}; void bubble(struct Card A[], int N){ for(int i=0; i&lt;N; i++){ for(int j = N-1; j &gt;= i+1; j--){ if(A[j].value &lt; A[j-1].value){ Card t= A[j]; A[j]=A[j-1]; A[j-1]=t; } } } } void selection(struct Card A[], int N){ for(int i=0; i&lt;N;i++){ int minj = i; for(int j=i; j&lt; N; j++){ if(A[j].value &lt; A[minj].value) minj = j; } Card t = A[i]; A[i] = A[minj]; A[minj] = t; } } void print(struct Card A[], int N){ for (int i=0; i&lt;N; i++){ if(i&gt;0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; A[i].suit&lt;&lt; A[i].value; } cout &lt;&lt; endl; } bool isStable(struct Card C1[], struct Card C2[], int N){ for( int i=0; i&lt; N;i++){ if(C1[i].suit != C2[i].suit) return false; } return true; } int main(){ Card C1[100], C2[100]; int N; char ch; cin &gt;&gt; N;&apos; for( int i=0; i&lt; N;i++){ cin &gt;&gt; C1[i[.suit &gt;&gt; C1[i].value; } for(int i=0; i&lt;N; i++) C2[i] = C1[i]; bubble(C1,N); selection(C2, N); print(C1,N); cout&lt;&lt; &quot;Stable&quot; &lt;&lt; endl; print(C2, N); if( isStable(C1,C2,N){ cout&lt;&lt; &quot;Stable&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;not stable&quot; &lt;&lt; endl; } return 0; } 5. 希尔排序法我们在插入排序法的基础上进一步发挥，将包含ｎ个整数的数列A通过下列程序进行升序排列。 insertionSort(A,n,g) for i = g to n-1 v = A[i] j = i - g while j &gt;= 0 &amp;&amp; A[j] &gt; v A[j+g] = A[j] j = j - g cnt ++ A[j+g] = v shellSort(A,n) cnt = 0 m = ? G[] = {?,?,?,?,…,?} for i = 0 to m-1 insertionSort(A, n, G[i]) insertionSort(A,n,g)是以间隔为g的元素为对象进行的插入排序。shellSort(A,n)则是insertionSort(A,n,g)的循环，并在每轮循环后逐渐缩小g的范围。这种排序方法称为希尔排序法。 C++ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; using namespace std; long long cnt; int l; int A[1000000]; int n; vector&lt;int&gt; G; //指定了间隔g的插入排序 void insertionSort(int A[], int n, int g){ for( int i = g; i&lt; n; i++){ int v = A[i]; int j = i - g; while (j &gt;= 0 &amp;&amp; A[j] &gt; v){ A[j+g] = A[j]; j -= g; cnt++; } A[j+g] = v; } } void shellSort( int A[], int n){ //生成数列 G={1,4,13,40,121,364, 1093,...} for (int h=1; ; ){ if(h &gt; n) break; G.push_back(h); h = 3*h + 1; } for ( int i = G.size()-1; i&gt;= 0; i--){ //按逆序指定G[i] = g insertionSort(A, n, G[i]); } } int main(){ cin &gt;&gt; n; //使用速度更快的scanf函数进行输入 for ( int i=0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]); cnt = 0; shellSort(A,n); cout &lt;&lt; G.size() &lt;&lt; endl; for( int i= G.size() - 1; i &gt;= 0; i--){ printf(&quot;%d&quot;, G[i]); if(i) printf(&quot; &quot;); } printf(&quot;\n&quot;); printf(&quot;%d\n&quot;, cnt); for ( int i = 0; i &lt; n; i++) printf(&quot;%d\n&quot;, A[i]); return 0; }]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 Socket]]></title>
    <url>%2Fyear%2F02%2F13%2F858%2F</url>
    <content type="text"><![CDATA[1. Socket 基础 Socket原指“孔”或“插座”，它最初作为BSD UNIX的进程通信机制，通常被称作“套接字”。当然，如今Socket已经是Windows和Mac等其他操作系统所共同遵守的网络编程标准，用于描述IP地址和端口，是一个通信连的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。Internet上的主机一般运行了多个服务软件，同时提供几种服务，每种服务都打开一个Socket，并绑定到一个端口上，不用的端口对应不同的服务。 在操作系统结构上，Socket为应用程序屏蔽了TCP/IP网络传输层及以下的网络细节，如图所示。Socket为操作系统的用户空间提供网络抽象，开发者编写的网络程序都会直接或间接地用到Socket抽象。通过Socket抽象可以控制传输层协议TCP和UDP,甚至包括部分网络层协议，例如IP和ICMP。Socket使用IP地址＋端口＋协议的三元组唯一标识一个通信链路。服务器端的一个通信链路可以对应于多个客户端，比如一个Web服务器端的80端口可以同时服务于大量的客户端。 2. 实战演练: Socket TCP 原语 用Socket进行网络开发需了解服务器和客户端的Socket原语，每个原语在不同的高级语言中都有相应的实现方式。TCP的Socket原语如图所示，所有基于TCP的Socket通信都遵循如图所示的流程。下面解释每个原语的含义。socket(): 建立Socket对象。Socket是以类似文件系统的文件系统【打开、读写、关闭】的模式设计的，socket()原语相当于“打开”。socket()原语的参数通常包括使用的传输层协议类型、网络层类型等。 bind(): 绑定。在参数中需要传入要绑定的IP地址和端口。IP地址必须是主机上的一个可用的地址（除了0.0.0.0指定绑定所有的本机IP）。端口必须是一个该Socket协议未被占用的端口，比如当一个主机上的两个程序试图同时绑定到80端口时，只有一个程序能够成功。服务器端程序在listen()之前必须进行bind()操作,而客户端程序如果在connect()原语之前没有调用bind()，则系统会自动为该Socket分配一个未被占用的地址和端口。 技巧: 当主机上存在多个IP时，绑定地址0.0.0.0可以监听所有这些可用的IP。 listen():监听。只在服务器端有用，告诉操作系统开始监听之前绑定的IP地址和端口，可以下参数中指定允许排队的最大连接数量。 connect():在客户端连接服务器。参数中需要指定服务器的地址和端口。调用connect()可能有两种结果，即与服务器端完成TCP３次握手并建立连接或者连接服务器失败。 accept():接受连接。只在服务器端有用，从监听到的连接中取出一个，并将其包装成一个新的Socket对象。这个新的Socket对象可被用于和相应的客户端进行通信。完成accept()标志着Socket已经完成TCP链路建立阶段的3次握手。如果当前没有客户端连接请求，则accept()调用会阻塞等待。 send():发送数据。服务器端和客户端均可调用send()向对方发送数据，在sendI)的参数中传入要发送的数据，通过send()的返回值判断数据是否发送成功。 recv():接收数据。服务器端和客户端均可调用recv()从对方接收数据。如果Socket中没有消息可以读取，则在默认情况下recv()调用会被阻塞直到消息到达；开发者也可以将Socket()设置为非阻塞模式，使recv()以失败形式返回。 close():关闭连接。通信中的任何一方可以调用close()发起关闭连接请求，另一方收到后也可调用close()关闭连接。 【示例】下面通过Python代码演示Socket编程方法，TCP服务器端的代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socketimport datetime HOST=’0.0.0.0’PORT=3434 #AF_INET说明使用IPV4地址， SOCK_STREAM指明TCPs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST,PORT))s.listen(1) while True: conn,addr = s.accept() print ‘Client %s connected!’ % str(addr) dt = datetime.datetime.now() message = “Current time is “ + str(dt) conn.send(Sent: “, message conn.close()包socket封装了所有python的原生Socket操作，代码中通过socket(),bind(),listen()的一系列调用实现了对指定端口的监听，通过accept()接受客户端的连接，当有客户端连接成功后将当前系统时间发送给客户端，并马上关闭连接。因为代码主体处于while循环中，所以程序将不断监听并一直运行。 与该服务器端的代码相对应的客户端代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘127.0.0.1’PORT = 3434 #AF_INET说明使用IPV4地址， SOCK_STREAM指明TCP协议 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) print ‘Connect %s:%d OK!’ % (HOST, PORT) data = s.recv(1024) #接受数据，最大长度为1024 print ‘Received: ‘, data s.close()客户端通过connect()调用、连接服务器，连接成功后接收从服务器发来的数据，然后关闭连接、退出程序。 注意：客户端的Socket端口号由系统自动分配。 3.Socket UDP原语UDP相对于TCP在传输层提供更少的控制，没有建立连接、断开连接等概念，所以基于UDP的Socket通信过程也比TCP稍微简单。在UDP中可以直接指定IP:Port进行数据收发。UDP Socket可以复用TCP中的socket()和bind()原语，除此之外，UDP属于自己的Socket原语如下。 recvfrom():从绑定的地址接收数据。 sendto():向指定的地址发送数据，在调用的参数中应该传入通信对端的地址和端口。 【示例】UDP的python服务器端的代码示例如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘0.0.0.0’PORT = 3434 #AF_INET说明使用IPV4地址， SOCK_DGRAM指明UDPs = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)s.bind() while True(): data, addr = s.recvgrom(1024) print ‘Received: %s’ % (data, str(addr)) s.close()代码通过socket()和bind()调用绑定了本地所有地址的3434端口，通过socket()中的SOCKET_DGRAM指定Socket使用UDP, 在一个循环中不断地接收数据并打印。相应的UDP客户端python代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘127.0.0.1’PORT = 3434 #AF_INET说明使用IPV4地址，socket.SOCK_DGRAM指明UDPs = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) data = “Hello UDP!”s.sendto(data, (HOST, PORT))print “Sent: %s to %s:%d” % (data, HOST, PORT) s.close()]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vultr VPS上搭建Shadowsocks]]></title>
    <url>%2Fyear%2F02%2F07%2F57013%2F</url>
    <content type="text"><![CDATA[作为一个离开Google就没法生活的人，之前也尝试了很多方法。这次自己搭建vpn,也折腾了不少，值得好好记录一下。废话少说，直接进入正题。 1.VPS的选择 可选择的VPS有很多，国内有阿里云、腾讯云，不过随着国内管控越来越严，在国内厂商的VPS上搭建VPN不是一个好的选择(你懂得)。知乎上有个相关话题,需要的可以参考一下。我选择Vultr是因为它便宜，在这里说我也不怕嘲笑，我还是个穷学生，经济问题还是首先要考虑的。可选择的套餐很多，5 $/mon还可以接受。 进入官网后注册登录后还要先充值10，当时我想先充0.01得了，结果人家不傻，最低要10$，也算了，为了我的Google,花点钱也可以学点东西。选择好位置、价格后，其他的默认就行了，然后就可以部署了。 提示：系统最好选择centos 6，方便部署 2.在VPS上部署Shadowsocks首先先登录到VPS上，我系统是Ubuntu 16.04 LTS,直接ssh root@your vps ipaddress ipaddress可以在这里看密码是系统默认生成的，如果需要修改密码，可以参考这个官方教程。 2.1下面开始进入重点，部署Shadowsocks服务端.这里使用 teddysun 的一键安装脚本。 依次输入下面三条命令 wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2>&1 | tee shadowsocks.log 最后一步输完，你应该会看到下图中内容──是要你为 Shadowsocks 服务设置一个个人密码。 设置 ss 密码输好回车后会让你选择一个端口，输入 1-65535 间的数字都行。 设置 ss 端口 遵照上图指示，按任意键开始部署 Shadowsocks。这时你什么都不用做，只需要静静地等它运行完就好。结束后就会看到你所部署的 Shadowsocks 的配置信息。 ss 配置信息记住黄框中的内容，也就是服务器 IP、服务器端口、你设的密码和加密方式。 2.2 TCP Fast Open实际上只要具备上述四个信息，你就可以在自己的任意设备上进行登录使用了。但是为了更好的连接速度，你还需要多做几步。 首先是打开 TCP Fast Open，输入以下命令，意为用 nano 这个编辑器打开一个文件。 nano /etc/rc.local 你的「终端」会刷新一下，出现下图。 别慌张，它就是个文本编辑器。用方向键把光标移到最末端，粘贴下面这一行内容，然后按 Ctrl + X 退出。 echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 输入“Y”并回车确认退出。 然后依法炮制，输入：nano /etc/sysctl.conf 在文末加上下面的内容，保存退出。 net.ipv4.tcp_fastopen = 3 打开一个 Shadowsocks 配置文件。 nano /etc/shadowsocks.json 把其中 “fast_open” 一项的 false 替换成 true。 “fast_open”:true 如果你希望添加多用户的话，可以将 “password” 字段如下图修改。其中，”22345”:”password1”意为该用户使用 22345 端口、以“password1”为密码连接登录 Shadowsocks。 保存退出。最后，输入以下命令重启 Shadowsocks。 /etc/init.d/shadowsocks restart 2.3 安装 Shadowsocks 客户端客户端安装就简单很多了，Android、Win、Mac这里就不再多述了。Linux客户端配置还是很麻烦的，改天再单独写个教程。 3.开启锐速完成上述步骤后，使用过程中可能会发现连接速度有时不太稳定。这就是「锐速」发挥功能的时候了。 3.1 什么是锐速锐速 ServerSpeeder 是一个 TCP 加速软件，对 Shadowsocks 客户端和服务器端间的传输速度有显著提升。而且，不同于 FinalSpeed 或 Kcptun 等需要客户端的工具，「锐速」的一大优势是只需要在服务器端单边部署就行了。换句话说，你不需要再安装另外一个应用。另外，「锐速」虽然已经停止注册和安装了，不过网上还是有不少「破解版」可用。 3.2 部署锐速首先需要用 SSH 登录 VPS。 ssh root@your vps ipaddress 依然使用一键安装脚本，输入以下命令。 wget -N –no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh && bash serverspeeder-all.sh 安装需要一段时间，等待一会。如果出现下图内容，请按提示输入数字。另外，若运行中碰到提示说需要更换内核的话，请参考此文更换之。 安装完成后，输入以下命令打开配置文件。 nano /serverspeeder/etc/config 将 advinacc 的 0 改为 1，保存并退出。 退出「终端」程序。至此，整个搭建过程就大功告成了！接下来，尽情地享受起飞的速度吧😄 需要帮助的话直接联系我。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>vps</tag>
        <tag>ss</tag>
      </tags>
  </entry>
</search>
