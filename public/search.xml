<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Looking up at the stars]]></title>
    <url>%2Fyear%2F03%2F14%2F29068%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vim精简版教程]]></title>
    <url>%2Fyear%2F03%2F13%2F12935%2F</url>
    <content type="text"><![CDATA[编辑器的分类 文本编辑器，ASCII码 字处理器：word全称 vi：Visual interface vim: Visual interface improved分类 全屏编辑器, vimEmacsnotepad++… 模式编辑器 grepsedawk vim模式：1.编辑模式（命令模式）2.输入模式3.末行模式4.可视化模式（块）默认处于编辑模式模式转换编辑模式（命令模式） —&gt;&gt;输入模式i：在当前光标所在字符的的前面，转换为输入 a：在当前光标所在字符的的后面，转换为输入 o:在当前光标所在字符的行下方，新建一行，并转为输入模式。 I:在当前光标所在行的行首，转为输入模式 A:在当前光标所在行的行尾，转为输入模式 O:在当前光标所在行的上方，新建一行，并转为输入模式。输入模式—&gt;编辑模式（命令模式)ESC键编辑模式（命令模式）—-&gt;&gt;末行模式:10d10,20dset nu!ls /etc末行模式—-&gt;&gt; 编辑模式（命令模式）ESC ESC键一.打开文件：vim filenamevim /path/to/somefilevim +12 file ：打开文件，光标在12行vim +# file :打开文件，光标在N行vim + file：打开文件，光标在最后一行。vim +/pattern file ：打开文件，光标在第一个匹配的行首二.关闭文件：1.末行模式关闭文件:q 退出:q!:wq 保存退出；w 保存：w! 强制保存:wq –&gt; :x 2.编辑模式（命令模式）ZZ:保存退出 三.移动光标（编辑模式）1.逐字符移动： h:向右 j:向下 k:向上 l:向左 数字h 5h：向右移动5个字符 2.逐个单词移动 w:移动到下一个单词词首 e：跳到当前单词或下一单词的词尾 b：跳到当前单词或前一单词的词首 #w：一次跳n个单词。 4b: 行内跳转0：跳到行首(绝对行首)^:行首的第一个非空白字符$:绝对行尾4.行间跳转#G：跳转到n行G：最后一行GG：第一行 末行模式 ：# 移动到n行 四、翻屏编辑模式（命令模式）f： 向后翻一屏、CTRL+b:向上翻一屏 Ctrl+d： 向下翻半屏Ctrl+u:向上翻半屏 五、删除单个字符x：删除光标所在处的单个字符 #x:删除光标所在处及向后n个字符 六、删除命令：dd命令跟跳转命令组合使用dw：3dw： #de，#dbdd：删除当前光标所在行 #dd：删除当前光标所在行及下面共#行 末行模式下startadd，Endaddd1,8d.,5+d.:表示当前行$:表示最后一行+#：向下#行1,$-3d: 最后一次删除的内容，可以粘贴到别处 七、粘贴命令pp:如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；P:如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面； 八、复制命令 yyy：一行 #y： 九、先删除内容，在转换为输入模式(修改)c：同d命令c$:cc:5C: 十、替换r:替换单个字符R：进入替换模式 十一、撤销编辑操作：u:撤销前一次的操作： 连续u，撤销此前n次操作3u #u：撤销最近#次操作 十二、撤销上一次的撤销Ctrl+r恢复 十三、重复前一次编辑操作. 十四、可视化模式v：按字符选取V：按矩形选取Ctrl+v: 十五、查找/pattern?patternnN 十六、查找并替换在末行模式下 用法和sed一样 address1，address2s/pattern/string/gi 1，$ %:表示全文。 十七、打开多个文件vim file1 file2;next 切换至下一个文件：prev 切换至前一个文件：last 切换至最后一个文件：first 切换最前面的一个文件退出：qall 全部退出 十八：分屏显示一个文件ctrl+w ,s:水平分割窗口ctrl+w,v:垂直分割窗口 在窗口间切换光标Ctrl+w，ARRON ：qa 关闭所有窗口 十九、分窗口多个文件vim -o file1 file2 file3 ..水平分割窗口vim -O file1 file3 …. 垂直分割窗口 二十、将当前文件部分内容另存为另一文件末行模式下使用w命令：w：add1,addr2w /path/to/somewhere 二十一、将另一个文件的内容填充在当前文件中：r /path/to/somefile 二十二、跟shell交互：!command 二十三、高级话题1.显示或取消行号：set numberset nu：set nonu2、显示忽略大小写或区分大小写set ignorecaseset ic:set noignorecase:set noic3.设定自动缩进：set autoindent:set noai 4.查找的文本高亮显示或取消：set hlsearch:set nohlsearch 5.语法高亮:syntax on:syntax off 二十四、配置文件/etc/vimrc~/.vimrc(家目录下) 二十五、练习vim的小游戏vimtutorvim -r file总结以上都是我大学的时候，学习的笔记，无意间看到了，发现很多东西都忘记了，现在准备复习一下，分享在这里。下面赠送一个安装vim插件的命令。神器： wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[青春，呼啸而过]]></title>
    <url>%2Fyear%2F03%2F12%2F27979%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; &nbsp;&nbsp;今天不经意间又翻到这篇文章，第一次读是在初三吧，那时候就特别有感触，可能是因为也同样有过这样相似的经历吧。原来的那些人，早已物是人非。 &nbsp;&nbsp; &nbsp;&nbsp; 在教室里我们习惯往窗外看，有一只鸟，从这棵树飞向另一棵树，它自由地去喉叫属于它自己的青春，这些都是窗子内的我最羡慕的事。 —-题记 &nbsp;&nbsp; &nbsp;&nbsp;高四开学的第一个傍晚，原本想放弃一切安心学习的我受不了同学的诱惑而跟他们去踢球。我不知道在这种特殊的时期下踢球是不是一种错误，或许我们选择的是一份自由，而在那次球赛上我认识了他—-老鸟。 &nbsp;&nbsp; &nbsp;&nbsp;我一个“踩单车”便轻松摆脱了老鸟的堵截，一脚抽射，球轻而易举地进了球门外的臭水沟。老鸟伸出姆指说“强”。我问老鸟为什么说我强，我并没有把球踢进去啊？老鸟说是看了我托着一双废品回收店里的托鞋还来踢球，真的是暴强。那天院长在我身边，我拿起他那只断了一半的托鞋扔向老鸟，怒喊道:我乐意。老鸟缩下头躲着，破口大骂，我不知道他骂什么，因为托鞋打到了他的嘴巴。 &nbsp;&nbsp; &nbsp;&nbsp; 院长挡在我们中间，我没跟老鸟打架。后来我跟老鸟还经常在足球场上交流，但彼此都很鄙视对方，直到高四上学期快结束的某一个晚上，我们几个人都没去上晚自习，踢完球后直接回宿舍洗澡间老鸟则跑到厕所里抽烟，我真的不明白老鸟为什么总躲在厕所里抽烟，随口问他难道单纯地只是不让老师看到吗。 &nbsp;&nbsp; &nbsp;&nbsp;最后老鸟才告诉我，别以为厕所是最臭、最恶心的地方，其实厕所是校园唯一安静的地方。这里不用去想那些矛盾的事情，而且可以把所有的烦恼都排泄到这里，静静地，一个人抽烟，人们总在这里留下什么，却又无法带走。 &nbsp;&nbsp; &nbsp;&nbsp;那晚，厕所里的灯光昏黄昏黄的，我也喜欢上了呆在厕所里抽烟。老鸟跟我说他除了足球也喜欢摇滚，喜欢汪峰，我没想到我可以和老鸟同穿一条裤子，更无法猜测喜欢摇滚的人的疯狂外表下其实是一颗坦诚的心。后来我跟老鸟唱完了汪峰的《笑着哭》后，老鸟头一次没装逼，对我说：我当你是兄弟…… &nbsp;&nbsp; &nbsp;&nbsp;有时候听着摇滚就会忘记老鸟的爱情悲剧史，醒来的时候模糊记得老鸟那个时候整天拿着我的《围城》，而且动不动就说：对丑女细看是种残忍。 &nbsp;&nbsp; &nbsp;&nbsp;“对丑女细看是种残忍”这句话的直接受害者就是我们的校花。老鸟每次见到她就损她几句，本以为校花会恨透老鸟，给我们这些渴望“脱光”者（摆脱光棍）一个机会，没想到那天我硬着头皮向老鸟要回《围城》的时候，老鸟竟公布校花成了他的女朋友。 &nbsp;&nbsp; &nbsp;&nbsp;我说，不会吧，你这屎克螂也有人要，快说，你是用多少金币收买人家的。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟说，有钱我就买泡面了，是她主动写情书给我的。这仿佛告诉我拉登就藏在他家一样。最后老鸟瞪了我一眼笑着说，随便玩玩而已，我不会动真格的，随后便去跟校花约会了。我骂道，你他妈的老鸟，你不要也不给我机会啊…… &nbsp;&nbsp; &nbsp;&nbsp;到了高四下学期，我跟老鸟算是成了真正的兄弟。除了足球、摇滚外，老鸟不断地向我炫耀他那无法验证的爱情史。 &nbsp;&nbsp; &nbsp;&nbsp;他时不时地叼着一支七匹狼的烟，看起来蛮帅的样子，随后他又开谈他跟校花过家家式的爱情剧，他总是说他毫不在意校花：“她的一举一动在我心里好像蜻蜓点水一样，即使泛起一丝波澜最后也归于平静。” &nbsp;&nbsp; &nbsp;&nbsp;可事实是：那天中午校花跑到男生宿舍哭，宿管人员十分无奈，找到老鸟并且对他说：“你拉屎还让我帮你擦屁股啊。”老鸟马上跑过来对我说，这搞的他十分惭愧，真想当场挖个洞把自己埋了。 &nbsp;&nbsp; &nbsp;&nbsp;爱情剧演到最后的时候，校花在班上号啕大哭，老鸟又坐到我旁边对我说：“我真的是无地自容，这真的是扒光我的衣服然后把我放到讲台上。” &nbsp;&nbsp; &nbsp;&nbsp;到了晚上，老鸟约大家去KTV，我们一如既往地点了摇滚歌曲《无地自容》，我不知道我们为什么老是点这首歌，我们这帮人还是老鸟、院长、俊、阿元、我，始终没变过，也没想过要变。 &nbsp;&nbsp; &nbsp;&nbsp;鬼哭狼嚎完后，老鸟说他们分手了。 &nbsp;&nbsp; &nbsp;&nbsp; 我说好啊，失恋也别太伤心，被抛弃后还是男人。 &nbsp;&nbsp; &nbsp;&nbsp; 老鸟没砍我，而是跟我拼酒。当然啦，我肯定敌不过她，不过喝到一半他就哭了，他不会转过头去，是那么坦然，任眼泪流淌。 &nbsp;&nbsp; &nbsp;&nbsp; 之后发生了什么我基本想不起来了，我模糊记得在宿舍里我吐得一塌糊涂时老鸟递给我毛巾和水。可从那以后，我们没再去那家菜给得不是很多的KTV，因为我们成长在这个残酷的时期。 &nbsp;&nbsp; &nbsp;&nbsp;高考结束后我们到离家很远的一个包装工厂里打工，之所以选择在这个破烂的地方是因为这里离家很远，远的忘记了高考。 &nbsp;&nbsp; &nbsp;&nbsp;还是原班人马，我们这几个曾经在晚自习上吼叫《无地自容》，每天踢球踢得很晚，跑回宿舍呆在厕所里抽烟的这帮家伙。但是这里我们告别了足球、告别了摇滚，因为我们已经经历了两次高考。 &nbsp;&nbsp; &nbsp;&nbsp; 单调而劳累的工作后，我们疲倦地躺在杂乱的宿舍里。老鸟说他真想K歌，他怀念高四的残忍与痛快。我看了他一眼，太多的心事其实不必说出口，因为我们彼此明白，我想老鸟是累了，不光是工作么累，每个高考失败的学子都会回想属于他的那一段忧伤，这里不曾有爱情，只有友谊与珍惜……我们轻轻地唱着汪峰的《美丽世界的孤儿》，我们都哭了，不知道为什么，可能我们早已被世人遗忘，只是这个美丽世界的孤儿。 &nbsp;&nbsp; &nbsp;&nbsp; 生活总是太无聊，特别是在这个高考后的日子里。但是老鸟还是会寻找属于自己的快乐，除了老鼠和蟑螂，包装厂里不缺的就是废纸和胶带，于是老鸟用胶带包起一大摞废纸便产生了世界上最原始的足球，而厂房便是我们的足球场，任何时候都是比赛时间，这些仅仅是老鸟和我遗忘世界的方式。 &nbsp;&nbsp; &nbsp;&nbsp;不过这个伟大的发明在工厂里的玻璃碎后被老板扼杀了，老鸟并没有生气，如果在以往他肯定会跟老板大干一场，可是今天他只是异常失落，或许他的心早已疲惫。 &nbsp;&nbsp; &nbsp;&nbsp;在宿舍里，我安慰老鸟说：“没事，心在足球就在，自由不需要方式。” &nbsp;&nbsp; &nbsp;&nbsp;老鸟头一次点了点头，真的像一只受伤的鸟儿。“我想她了。”他一头扎进我的怀中。 &nbsp;&nbsp; &nbsp;&nbsp;我叹了叹气，我想就我知道他是一个受伤的孩子，他是真心对她的，但是他不会说出口，哪怕到最后分手，哪怕自己受伤，永远不会，他是一个任性的孩子。 &nbsp;&nbsp; &nbsp;&nbsp; “我心很痛，很痛。”老鸟哭了，头一次他自己哭我没陪他，因为这是属于他自己的故事…… &nbsp;&nbsp; &nbsp;&nbsp; 我跑到楼下买了一个二手的低音炮，插上MP3。“想唱点什么歌？”我笑着问。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟掀开头上的被子，无奈地笑着说：“《谁伴我闯荡》。” &nbsp;&nbsp; &nbsp;&nbsp;“前面是哪方/谁伴我闯荡/前路没有指引/若我走上又是窄巷/寻梦像扑火/谁共我疯狂……”低音炮的声音很小，但是我们依旧喉破了喉咙，其实歌声响起的时候世界很安静，老鸟和我都在宁静中流下了寂寞的泪水。 &nbsp;&nbsp; &nbsp;&nbsp; 8月，我们还在工厂里打工，录取结果下来了，我们这群经历过两次高考的孩子竟然异常冲动与恐惧。一大早老鸟就约我去网吧，但是他还说：“你先查吧，我再也经不起打击了。” &nbsp;&nbsp; &nbsp;&nbsp; …… &nbsp;&nbsp; &nbsp;&nbsp; 我被北方一所本科高校录取，专业是我向往的中文系。老鸟说，跑那么远干吗，看来你是没有福气跟我踢球、摇滚了，很不幸啊。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟没有告诉我他的录取结果，只是在我要去上大学的前一个晚上老鸟来送我。 &nbsp;&nbsp; &nbsp;&nbsp; 那晚，老鸟仅仅是穿着一件陈旧的牛仔裤和褶皱的衬衣。突然觉得他的衬衣像是我们过去的回忆，所有无法留住的点滴都将折叠起来。今人兴奋的是老鸟终于背起了吉他。 &nbsp;&nbsp; &nbsp;&nbsp;老鸟笑了笑，他的脸异常干燥，像是野地。“怎么样，我比你早学会了吉他，不用低音炮我也可以自己摇滚了。” &nbsp;&nbsp; &nbsp;&nbsp;我竟有一种说不出的感动，却忘记了我们即将告别，就像今晚的月色，是如此朦胧，如此凄美，引人入醉，醒来却是无限的疼痛。“来首什么歌曲呢？” &nbsp;&nbsp; &nbsp;&nbsp;老鸟很霸道地说：“丫的，你懂个屁，这次我自己弹唱。”他接着说：“只送给你的，一个人。” &nbsp;&nbsp; &nbsp;&nbsp;我没有反驳他，或许在他面前我已经失去了反驳的力量，只要期待着他这个无法结束的故事。 &nbsp;&nbsp; &nbsp;&nbsp; 是达达乐队的《南方》，听到旋律我就知道了，突然发现老鸟的声音很有磁性，仿佛回到高四的教室，那里有排得长长的书;我们躲在厕所里抽烟，哭着唱完了汪峰的歌曲;我们一起在KTV里吼歌，等喉咙快吼破的时候我们一起拼酒;在宿舍吐得一踏糊涂的时候老鸟给我递来热水和毛巾……这些陈旧的往事都将折叠在老鸟褶皱的衬衣上，借着凄凉的月光，竟是如此忧伤，我哭了…… &nbsp;&nbsp; &nbsp;&nbsp;“那里总是很潮湿/那里总是很松软/那里总是很多琐碎事/那里总是红和蓝/就这样一天天浪漫/就这样一天天感叹……南方……”老鸟唱着唱着也哭了，我没有问老鸟将要何去何从，他也只是说了声珍重就离开了。那晚老鸟背着吉他，背着他的摇滚梦离开了，我也离开了南方，可至今依旧感伤…… &nbsp;&nbsp; &nbsp;&nbsp; 我真的摸不清这个故事，我也没法去扮演这个角色了。老鸟离开的时候我仿佛发觉：现实总是背叛想象的。一切就像老鸟的高四，面对着残忍却去选择另一种痛苦，他是被青春遗忘的孤儿，拥有遥不可及的梦，或许，青春的我们都失去了年少的背影。 &nbsp;&nbsp; &nbsp;&nbsp; 之后大学的某个早上，我背起吉他的某个早上，我听到有人在弹唱《南方》:“我第一次恋爱在那里/不知她现在怎么样/我家门前的湖边/这时谁还在流连/时间过得飞快/转眼这些已成回忆/每天都有新的问题/不知何时又会再忆起……” &nbsp;&nbsp; &nbsp;&nbsp;这声音再熟悉不过了，我的眼泪突然哗哗流下，不顾一切跑了过去……]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构笔记]]></title>
    <url>%2Fyear%2F03%2F11%2F28074%2F</url>
    <content type="text"></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库原理笔记]]></title>
    <url>%2Fyear%2F03%2F11%2F43793%2F</url>
    <content type="text"></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git push失败]]></title>
    <url>%2Fyear%2F03%2F10%2F36673%2F</url>
    <content type="text"><![CDATA[刚才在将本地文件夹上传到github上时出现下面报错12$ git push -u origin masterfatal: unable to access 'https://github.com/hao14293/blogbackup.git/': gnutls_handshake() failed: Error in the pull function. 解决方法1$ git config --global credential.helper store 然后再次1$ git push -u origin master 输入Username Password就完美解决了。]]></content>
      <categories>
        <category>Git and Github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[玩转运动世界校园]]></title>
    <url>%2Fyear%2F03%2F10%2F29072%2F</url>
    <content type="text"><![CDATA[本来今天打算写个刷运动世界校园的教程，结果一大早起来发现，用模拟器刷的方法炸了，弄了半天也没解决，这篇文章先放这里，等有方法了再写。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装Eclipse]]></title>
    <url>%2Fyear%2F03%2F10%2F47249%2F</url>
    <content type="text"><![CDATA[配置 java 环境 官方下载jdk(我安装的是jdk1.8.0_161) 创建安装文件夹（我的是 /opt/java)sudo mkdir /opt/java 把下载下来的jdk-8u161-linux-x64.tar.gz 移到 /opt/java 并解压sudo mv /下载/jdk-8u161-linux-x64.tar.gz /opt/java sudo tar -zxvf jdk-8u161-linux-x64.tar.gz 配置环境变量sudo gedit /etc/environment 末尾加入以下配置（JAVA_HOME后的路径就是你jdk的文件位置） PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin" export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/opt/java/jdk1.8.0_161 修改完后保存关闭，输入下面命令使环境变量生效 source /etc/environment 但这个时候输入java -version发现是下面这样$ java -version程序 ‘java’ 已包含在下列软件包中： default-jre gcj-5-jre-headless openjdk-8-jre-headless gcj-4.8-jre-headless gcj-4.9-jre-headless openjdk-9-jre-headless请尝试：sudo apt install &lt;选定的软件包&gt;这是因为Ubuntu默认安装的有java环境，需要我们再配置以下 sudo update-alternatives –install /usr/bin/java java /opt/java/jdk1.8.0_161/bin/java 300 sudo update-alternatives –install /usr/bin/javac javac /opt/java/jdk1.8.0_161/bin/javac 300 sudo update-alternatives –install /usr/bin/jar jar /opt/java/jdk1.8.0_161/bin/jar 300 sudo update-alternatives –install /usr/bin/javah javah /opt/java/jdk1.8.0_161/bin/javah 300 sudo update-alternatives –install /usr/bin/javap javap /opt/java/jdk1.8.0_161/bin/javap 300 上面命令把每条后半部分地址改为你的jdk地址，/opt/java是我的地址。最后执行这条命令使之生效sudo update-alternatives –config java这个时候再执行java -version javac -version$ java -versionjava version “1.8.0_161”Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)$ javac -versionjavac 1.8.0_161这样就大功告成。 安装 Eclipse 官方下载 解压（我是单独创建了个eclipse文件夹）cd 下载/ sudo mv eclipse-inst-linux64.tar.gz /eclipse tar -zxvf eclipse-inst-linux64.tar.gz 进入文件夹双击eclipse-inst,然后就安装吧。（耐心） 创建快捷方式[Desktop Entry]Encoding=UTF-8Name=EclipseComment=EclipseExec=/home/ubuntu/eclipse/jee-oxygen/eclipse/eclipseIcon=/home/ubuntu/eclipse/jee-oxygen/eclipse/icon.xpmTerminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development;ExecIcon改成你的地址。对该文件进行赋权chmod u+x /usr/share/applications/Eclipse.desktop大功告成。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 基础教程]]></title>
    <url>%2Fyear%2F03%2F09%2F46251%2F</url>
    <content type="text"><![CDATA[Git 和 Github是同学们经常使用的工具，这里简单写个基础操作教程。 安装GitUbuntu sudo apt-get install git-core Mac OS X如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ Windows在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name "Your Name" $ git config --global user.email "email@example.com" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： mkdir learngit cd learngit pwd /home/ubuntu/learngit pwd命令用于显示当前目录。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： git init 初始化空的 Git 仓库于 /home/ubuntu/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可. 现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m "wrote a readme file" [master （根提交） a6ee6ed] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m "xxx"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m "add 3 files." 时光机穿梭 我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status 位于分支 master 尚未暂存以备提交的变更： （使用 "git add ..." 更新要提交的内容） （使用 "git checkout -- ..." 丢弃工作区的改动） 修改： readme.txt 修改尚未加入提交（使用 "git add" 和/或 "git commit -a"） git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status 位于分支 master 要提交的变更： （使用 "git reset HEAD ..." 以取消暂存） 修改： readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m "add distributed" [master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status 位于分支 master 无文件要提交，干净的工作区 Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 版本回退 git log命令可以查看历史记录 $ git log commit 4e77f2f8aada37a56fda295813a8b40847933dae Author: hao14293 Date: Thu Mar 8 13:07:05 2018 +0800 add commit a6ee6ed74739651569179c5aadc961a2b548a2a9 Author: hao14293 Date: Thu Mar 8 12:54:56 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline 4e77f2f8aada37a56fda295813a8b40847933dae add a6ee6ed74739651569179c5aadc961a2b548a2a9 wrote a readme file 需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 现在我们准备退回上一个版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 现在我们把当前版本回退到上一版本,就可以使用git reset命令： $ git reset --hard HEAD^ HEAD 现在位于 a6ee6ed wrote a readme file --hard参数有啥意义？这个后面再讲，现在你先放心使用. 打开readme.txt，已经回到上一个版本了。 工作区、暂存区和版本库 我们先来理解下Git 工作区、暂存区和版本库概念 * 工作区：就是你在电脑里能看到的目录。 * 暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 * 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： ![1.jpg](https://i.loli.net/2018/03/08/5aa0d97ba6186.jpg) 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status 位于分支 master 尚未暂存以备提交的变更： （使用 "git add ..." 更新要提交的内容） （使用 "git checkout -- ..." 丢弃工作区的改动） 修改： readme.txt 未跟踪的文件: （使用 "git add ..." 以包含要提交的内容） LICENSE 修改尚未加入提交（使用 "git add" 和/或 "git commit -a"） Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status 位于分支 master 要提交的变更： （使用 "git reset HEAD ..." 以取消暂存） 新文件： LICENSE 修改： readme.txt 现在，暂存区的状态就变成这样了： ![1.jpeg](https://i.loli.net/2018/03/08/5aa0db74a0056.jpeg) 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m "understand how stage works" [master f9c5b54] understand how stage works 2 files changed, 4 insertions(+), 2 deletions(-) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status 位于分支 master 无文件要提交，干净的工作区 现在版本库变成了这样，暂存区就没有任何内容了： ![2.jpeg](https://i.loli.net/2018/03/08/5aa0dbfc271a4.jpeg) Git 基本操作 * git init: 用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。在目录中执行 git init，就可以创建一个 Git 仓库了。 * git clone: 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 执行命令： git clone [url] [url] 为你想要复制的项目，就可以了。 * git add: git add 命令可将该文件添加到缓存 * git status: git status 以查看在你上次提交之后是否有修改。 * git diff: 执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 * * 尚未缓存的改动：git diff * * 查看已缓存的改动： git diff --cached * * 查看已缓存的与未缓存的所有改动：git diff HEAD * * 显示摘要而非整个 diff：git diff --stat * git commit: 使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 * git reset HEAD: git reset HEAD 命令用于取消已缓存的内容。 * git rm: 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。 * * 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作 git rm * * 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f git rm -f * * 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可 git rm --cached 如我们删除 hello.php文件： $ git rm hello.php rm 'hello.php' $ ls README * * 不从工作区中删除文件： $ git rm --cached README rm 'README' $ ls README * * 可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件： git rm –r * 进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。 * git mv: git mv 命令用于移动或重命名一个文件、目录、软连接。 我们先把刚移除的 README 添加回来： $ git add README 然后对其重名: $ git mv README README.md $ ls README.md 远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C "youremail@example.com" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 添加远程库 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:hao14293/learngit.git 请千万注意，把上面的hao14293替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -> master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 从远程库克隆 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:hao14293/gitskills.git Cloning into 'gitskills'... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd gitskills $ ls README.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/hao14293/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 分支管理 几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为"必杀技特性"，而正是因为它，将 Git 从版本控制系统家族里区分出来。 创建分支命令： git branch (branchname) 切换分支命令: git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 列出分支 列出分支基本命令： git branch 没有参数时，git branch 会列出你在本地的分支。 $ git branch * master 此例的意思就是，我们有一个叫做"master"的分支，并且该分支是当前分支。 当你执行 git init 的时候，缺省情况下 Git 就会为你创建"master"分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 $ git branch testing $ git branch * master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了"testing"分支，Git 将还原你的工作目录到你创建分支时候的样子 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ ls README $ echo 'runoob.com' > test.txt $ git add . $ git commit -m 'add test.txt' [master 048598f] add test.txt 2 files changed, 1 insertion(+), 3 deletions(-) delete mode 100644 hello.php create mode 100644 test.txt $ ls README test.txt $ git checkout testing Switched to branch 'testing' $ ls README hello.php 当我们切换到"testing"分支的时候，我们添加的新文件test.txt被移除了, 原来被删除的文件hello.php文件又出现了。切换回"master"分支的时候，它们有重新出现了。 $ git checkout master Switched to branch 'master' $ ls README test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtest Switched to a new branch 'newtest' $ git rm test2.txt rm 'test2.txt' $ ls README test.txt $ git commit -am 'removed test2.txt' [newtest 556f0a0] removed test2.txt 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ git checkout master Switched to branch 'master' $ ls README test.txt test2.txt 如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。 使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。 删除分支 删除分支命令： git branch -d (branchname) 例如我们要删除"testing"分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： git merge $ git branch * master newtest $ ls README test.txt test2.txt $ git merge newtest Updating 2e082b7..556f0a0 Fast-forward test2.txt | 1 - 1 file changed, 1 deletion(-) delete mode 100644 test2.txt $ ls README test.txt 以上实例中我们将 newtest 分支合并到主分支去，test2.txt 文件被删除。 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 $ git branch * master $ cat test.txt runoob.com 首先，我们创建一个叫做"change_site"的分支，切换过去，我们将内容改为 www.runoob.com 。 $ git checkout -b change_site Switched to a new branch 'change_site' $ vim test.txt $ head -1 test.txt www.runoob.com $ git commit -am 'changed the site' [change_site d7e7346] changed the site 1 file changed, 1 insertion(+), 1 deletion(-) 将修改的内容提交到 "change_site" 分支中。 现在，假如切换回 "master" 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。 $ git checkout master Switched to branch 'master' $ head -1 test.txt runoob.com $ vim test.txt $ cat test.txt runoob.com 新增加一行 $ git diff diff --git a/test.txt b/test.txt index 704cce7..f84c2a4 100644 --- a/test.txt +++ b/test.txt @@ -1 +1,2 @@ runoob.com +新增加一行 $ git commit -am '新增加一行' [master 14b4dca] 新增加一行 1 file changed, 1 insertion(+) 现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。 我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 $ vim test.txt $ cat test.txt www.runoob.com 新增加一行 $ git diff diff --cc test.txt index f84c2a4,bccb7c2..0000000 --- a/test.txt +++ b/test.txt @@@ -1,2 -1,1 +1,2 @@@ - runoob.com + www.runoob.com +新增加一行 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU test.txt $ git add test.txt $ git status -s M test.txt $ git commit [master 88afe0e] Merge branch 'change_site' 现在我们成功解决了合并中的冲突，并提交了结果。 标签管理 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 runoob 项目发布一个"1.0"版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）"v1.0"的标签。 -a 选项意为"创建一个带注解的标签"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了： $ git log --oneline --decorate --graph * 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site' |\ | * d7e7346 (change_site) changed the site * | 14b4dca 新增加一行 |/ * 556f0a0 removed test2.txt * 2e082b7 add test2.txt * 048598f add test.txt * 85fc7e7 test comment from runoob.com 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * 88afe0e (HEAD, tag: v1.0, master) Merge branch 'change_site' |\ | * d7e7346 (change_site) changed the site * | 14b4dca 新增加一行 |/ * 556f0a0 removed test2.txt * 2e082b7 add test2.txt * 048598f add test.txt * 85fc7e7 (tag: v0.9) test comment from runoob.com 如果我们要查看所有标签可以使用以下命令： $ git tag v0.9 v1.0 指定标签信息命令： git tag -a -m "runoob.com标签" PGP签名标签命令： git tag -s -m "runoob.com标签" Github …or create a new repository on the command line echo "# test" >> README.md git init git add README.md git commit -m "first commit" git remote add origin https://github.com/hao14293/test.git git push -u origin master …or push an existing repository from the command line git remote add origin https://github.com/hao14293/test.git git push -u origin master git将本地仓库推送到github 1. 首先在本地创建ssh key; $ ssh-keygen -t rsa -C "your_email@youremail.com" 2. 回到github，进入Account Settings，左边选择SSH Keys，Add SSH Key,title随便填，粘贴key。为了验证是否成功，在Git bash下输入： $ ssh -T git@github.com 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。 git config –global user.name “your name”git config –global user.email “your_email@youremail.com“ 进入要上传的仓库，添加远程地址： $ git remote add origin git@github.com:yourName/yourRepo.git(可以去git上复制仓库的地址)4.提交、上传 接下来在本地仓库里添加一些文件，比如README， git add README git commit -m “first commit” 上传到github： $ git push origin mastergit push命令会将本地仓库推送到远程服务器。 git pull命令则相反。]]></content>
      <categories>
        <category>Git and Github</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 程序快捷方式创建方法]]></title>
    <url>%2Fyear%2F03%2F09%2F43744%2F</url>
    <content type="text"><![CDATA[方法很简单，下面以创建Eclipse快捷方式为例。其他程序只需把名字改为对应名字就行。 sudo gedit /usr/share/applications/Eclipse.desktop 复制以下代码： [Desktop Entry] Encoding=UTF-8 Name=Eclipse Comment=Eclipse Exec=/home/ubuntu/eclipse/jee-oxygen/eclipse/eclipse Icon=/home/ubuntu/eclipse/jee-oxygen/eclipse/icon.xpm Terminal=false StartupNotify=true Type=Application Categories=Application;Development; 把Exec和Icon改为你的地址。 最后 sudo chmod u+x Eclipse.desktop]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows10环境下装Ubuntu双系统]]></title>
    <url>%2Fyear%2F03%2F08%2F56114%2F</url>
    <content type="text"><![CDATA[很多入门的小伙伴都想体验一下Linux，但又不舍得Windows,所以就想到了装双系统。我刚开始也是这样，大一开始折腾，虽然网上教程很多，但我第一次仔仔细细地按照教程做，最后还是没能成功，还把Windows上资料给弄没了。这两年也装过不少次系统了，所以今天想写一下教程，按照这个教程请放心安装，一定可以成功。 环境/工具 windows10 U盘（大于4G） Ultraiso ubuntu 16.04 LTS (百度云下载) 耐心 方法/步骤一. 制作Ubuntu 16.04启动盘1.插入用来制作启动盘的U盘（会被格式化，请备份好重要文件），打开UltraISO刻录软件（免费无限期试用）。 2.选择“文件(F)”-&gt;“打开”，找到“Ubuntu-16.04-desktop-amd64.iso”镜像文件，然后点击“打开”。3.选择“启动(B)”-&gt;“写入硬盘映像”，打开启动盘制作界面。4.然后点击下方的“写入”，会弹出警告提示，确定后，就会开始制作启动盘。写入完成后关闭UltraISO软件即可。 这样就制作好了启动盘。 二. 为Ubuntu系统分盘在Windows 10中打开“磁盘管理器”，找一个空闲的磁盘分区，压缩出来一部分空间给Ubuntu使用，压缩出来的硬盘应处于未分配状态。或者通过删除某个不使用的本地磁盘使其处于未分配状态。敲黑板:这个可能有人不太理解，其实很简单，如果你只有C盘，右击选择压缩磁盘，大小就是你要分出来的ubuntu系统的大小，想要好好用linux的同学最好分出大于40G。分出来后这部分是黑色的。 三. [BIOS设置]不同电脑进入BIOS方法不同，一般 F2键和 ESC键的比较多，可以试一下，不行的话可以自己百度。1.关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。 2.在BIOS中设置U盘为第一启动项，保存并重启电脑。不知道怎么设置的看这里:上图中的Boot Option #1就是第一启动项，按ENTER键和上下键选择你的U盘启动项后ENTER，然后保存后重启。 四. [安装Ubuntu 16.04 LTS] 这时候开机后会看到Try Ubuntu或者Install Ubuntu,选择Try Ubuntu，也就是第一个，Enter。 稍等一会儿进入UbuntuDesktop。 双击左上角的”Install Ubuntu 16.04LTS“，打开安装界面。（安装过程比较简单，根据提示输入一些信息即可）在左侧语言栏选择安装语言，然后点击“继续”。如果网速比较快，可以勾选“安装Ubuntu时下载更新”。（如果选择的语言是中文，这里在更新的时候会自动安装中文输入法，当然也可以安装完成后安装搜狗拼音输入法Linux版）注意注意，重点来了,一定要选择最后一个其他选项,不要有疑问，为了你的Windows安全。接下来要为Ubuntu系统分区，就像Windows下的C、D、E盘。网上有不同的分法，我的使用经验是分三个就行，分别是/boot、/swap和 /。 /boot我是分1G，swap分5G，剩下的全部分给/。我没截到图，图片是网上找的，就是先点分出来标注空闲的那个分区，然后点左下角+号，/boot /swap / 都是在挂载点里面选择。选择逻辑分区。把三个都分好。特别注意,分好后看最下面的安装启动引导器的设备,我第一次错就是在这里，这个要选择/boot 对应的sda，不然会失败。继续shanghai 继续继续名字、密码配好继续耐心等待可以拔掉U盘了，立即重启。如果此时黑屏的话不要紧张，电源键重启，开机后就会看到选择进入系统界面了，第一个就是Ubuntu系统，第三个是Windows，第二个也是Ubuntu，先不用管。然后，好好折腾你的Ubuntu吧！！！]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码暴力破解 '2018年刑侦科推理试题']]></title>
    <url>%2Fyear%2F03%2F07%2F42008%2F</url>
    <content type="text"><![CDATA[据说是2018年刑侦科推理试题，感受一下。 作为一个学渣，瞅一眼头就晕了，那就按老师说的‘不会的就选Ｃ吧’，不过仔细分析一下这题挺有意思的。 正常推理的话是这个样子： 读题知，第五题为核心题目。先假设第五题为A，则2为C,8为A。由8知，2、5、10与1相邻，则1为B。可知第6题排除A B，可知第9题中x与5答案相同，第9题若选A，则6为A不符合；不选C；若选D，矛盾；故9为B。则10为A。第6题排除D，故6为C。第4题为C。第3题为A。至此，选A有4，选C有3，选B有2，则7为D。证毕。(若第五题不为A，应继续假设为其他项证明之) 最后得出答案 BCACACDABA. 对于我这种脑子笨的人来说，推出来也差不多半个小时了。。。 那这题让程序员来做会怎么样呢？ 上代码。 Python def p0(ans, hypo): return True def p1(ans, hypo): if ans == 'A': return hypo[4] == 'C' if ans == 'B': return hypo[4] == 'D' if ans == 'C': return hypo[4] == 'A' if ans == 'D': return hypo[4] == 'B' return None def p2(ans, hypo): if ans == 'A': return hypo[2] != hypo[5] and hypo[2] != hypo[1] and hypo[2] != hypo[3] if ans == 'B': return hypo[5] != hypo[2] and hypo[5] != hypo[1] and hypo[5] != hypo[3] if ans == 'C': return hypo[1] != hypo[2] and hypo[1] != hypo[5] and hypo[1] != hypo[3] if ans == 'D': return hypo[3] != hypo[2] and hypo[3] != hypo[5] and hypo[3] != hypo[1] return None def p3(ans, hypo): if ans == 'A': return hypo[0] == hypo[4] if ans == 'B': return hypo[1] == hypo[6] if ans == 'C': return hypo[0] == hypo[8] if ans == 'D': return hypo[5] == hypo[9] return None def p4(ans, hypo): if ans == 'A': return hypo[4] == hypo[7] if ans == 'B': return hypo[4] == hypo[1] if ans == 'C': return hypo[4] == hypo[8] if ans == 'D': return hypo[4] == hypo[6] return None def p5(ans, hypo): if ans == 'A': return hypo[7] == hypo[1] and hypo[7] == hypo[3] if ans == 'B': return hypo[7] == hypo[0] and hypo[7] == hypo[5] if ans == 'C': return hypo[7] == hypo[2] and hypo[7] == hypo[9] if ans == 'D': return hypo[7] == hypo[4] and hypo[7] == hypo[8] return None def p6(ans, hypo): na, nb, nc, nd = 0, 0, 0, 0 for x in hypo: if x == 'A': na += 1 if x == 'B': nb += 1 if x == 'C': nc += 1 if x == 'D': nd += 1 min_opt = min(na, nb, nc, nd) if ans == 'A': return nc == min_opt if ans == 'B': return nb == min_opt if ans == 'C': return na == min_opt if ans == 'D': return nd == min_opt return None def p7(ans, hypo): x = ord(hypo[0]) if ans == 'A': return abs(x - ord(hypo[6])) != 1 if ans == 'B': return abs(x - ord(hypo[4])) != 1 if ans == 'C': return abs(x - ord(hypo[1])) != 1 if ans == 'D': return abs(x - ord(hypo[9])) != 1 return None def p8(ans, hypo): a = hypo[0] == hypo[5] if ans == 'A': return a != hypo[5] == hypo[4] if ans == 'B': return a != hypo[9] == hypo[4] if ans == 'C': return a != hypo[1] == hypo[4] if ans == 'D': return a != hypo[8] == hypo[4] return None def p9(ans, hypo): na, nb, nc, nd = 0, 0, 0, 0 for x in hypo: if x == 'A': na += 1 if x == 'B': nb += 1 if x == 'C': nc += 1 if x == 'D': nd += 1 delta = max(na, nb, nc, nd) - min(na, nb, nc, nd) if ans == 'A': return delta == 3 if ans == 'B': return delta == 2 if ans == 'C': return delta == 4 if ans == 'D': return delta == 1 return None def test_hypo(problem_list, hypo): index = 0 for p in problem_list: if not p.__call__(hypo[index], hypo): return False index += 1 return True def hypo_generator(size): num = 1 for x in range(size): num *= 4 hypo = [None] * size for i in xrange(num): for j in range(size): hypo[j] = ['A', 'B', 'C', 'D'][(i >> (j < 1)) & 3] yield hypo def main(): problem_list = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9] for hypo in hypo_generator(len(problem_list)): if test_hypo(problem_list, hypo): print 'Answer:', hypo if __name__ == '__main__': main() 'D'){ return false; } v[i] = c; if (!solve(v, i + 1, 'A') && !solve(v, i, c + 1)) { return false; } const int x = (c - 'A'); switch (i) { case 1: return true; case 2: if (v[5] == "CDAB"[x]) { return true; } break; case 3: { const int w[4] = { 3,6,2,4 }; int j = 0; for (; j < 4; ++j) { if (j != x && v[w[j]] == v[w[x]]) { break; } } if (j >= 4) { return true; } break; } case 4: if (v["1216"[x] - '0'] == v["579:"[x] - '0']) { // '9' + 1 = ':' return true; } break; case 5: if (c == v["8497"[x] - '0']) { return true; } break; case 6: if ((v["2135"[x] - '0'] == v["46:9"[x] - '0']) && (v["2135"[x] - '0'] == v[8])) { return true; } break; case 7: if ("CBAD"[x] - 'A' == stat(v, 'm')) { return true; } break; case 8: if (abs(v["752:"[x] - '0'] - v[1]) > 1) { return true; } break; case 9: if ((v[1] == v[6]) != (v["6:29"[x] - '0'] == v[5])) { return true; } break; case 10: if (("3241"[x] - '0') == stat(v, 'd')) { return true; } break; } return solve(v, i, c + 1); } int main() { const int n = 11; vector v(n); if (solve(v, 1, 'A')) { for (int i = 1; i < n; ++i) { cout < i < ' '; } cout < endl; for (int i = 1; i < n; ++i) { cout < v[i] < ' '; } cout < endl; } }]]></content>
      <categories>
        <category>cool-code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《我》]]></title>
    <url>%2Fyear%2F03%2F02%2F10484%2F</url>
    <content type="text"><![CDATA[我喜欢出发 喜欢离开喜欢一生中都能有新的梦想千山万水 随意行去我喜欢停留 喜欢长久喜欢在园里种下千棵果树期待冬雷夏雨 春华秋实喜欢生命里只有单纯的盼望只有一种安定和缓慢的成长我喜欢岁月漂洗过后的颜色喜欢那没有唱出来的歌我喜欢在夜里写一首长诗然后再来在这清凉的早上逐行逐段地检视慢慢删去每一个与你有着关联的字《我》 － 席慕蓉]]></content>
      <categories>
        <category>Zen and Reading</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫入门项目]]></title>
    <url>%2Fyear%2F03%2F01%2F33549%2F</url>
    <content type="text"><![CDATA[今天为大家整理了32个Python爬虫项目。 整理的原因是，爬虫入门简单快速，也非常适合新入门的小伙伴培养信心。所有链接指向GitHub，祝大家玩的愉快~ 1、WechatSogou [1]– 微信公众号爬虫。 基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。 github地址：https://github.com/Chyroc/WechatSogou 2、DouBanSpider [2]– 豆瓣读书爬虫。 可以爬下豆瓣读书标签下的所有图书，按评分排名依次存储，存储到Excel中，可方便大家筛选搜罗，比如筛选评价人数&gt;1000的高分书籍；可依据不同的主题存储到Excel不同的Sheet ，采用User Agent伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。 github地址：https://github.com/lanbing510/DouBanSpider3、zhihu_spider [3]– 知乎爬虫。 此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用scrapy，数据存储使用mongo github地址：https://github.com/LiuRoy/zhihu_spider 4、bilibili-user [4]– Bilibili用户爬虫。 总数据数：20119918，抓取字段：用户id，昵称，性别，头像，等级，经验值，粉丝数，生日，地址，注册时间，签名，等级与经验值等。抓取之后生成B站用户数据报告。 github地址：https://github.com/airingursb/bilibili-user 5、SinaSpider [5]– 新浪微博爬虫。 主要爬取新浪微博用户的个人信息、微博信息、粉丝和关注。代码获取新浪微博Cookie进行登录，可通过多账号登录来防止新浪的反扒。主要使用 scrapy 爬虫框架。 github地址：https://github.com/LiuXingMing/SinaSpider 6、distribute_crawler [6]– 小说下载分布式爬虫。 使用scrapy,Redis, MongoDB,graphite实现的一个分布式网络爬虫,底层存储MongoDB集群,分布式使用Redis实现,爬虫状态显示使用graphite实现，主要针对一个小说站点。 github地址：https://github.com/gnemoug/distribute_crawler 7、CnkiSpider [7]– 中国知网爬虫。 设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。 github地址：https://github.com/yanzhou/CnkiSpider 8、LianJiaSpider [8]– 链家网爬虫。 爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。 github地址：https://github.com/lanbing510/LianJiaSpider 9、scrapy_jingdong [9]– 京东爬虫。 基于scrapy的京东网站爬虫，保存格式为csv。 github地址：https://github.com/taizilongxu/scrapy_jingdong 10、QQ-Groups-Spider [10]– QQ 群爬虫。 批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。 github地址：https://github.com/caspartse/QQ-Groups-Spider 11、wooyun_public[11]-乌云爬虫。 乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在MongoDB中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。 https://github.com/hanc00l/wooyun_public 12、spider[12]– hao123网站爬虫。 以hao123为入口页面，滚动爬取外链，收集网址，并记录网址上的内链和外链数目，记录title等信息，windows7 32位上测试，目前每24个小时，可收集数据为10万左右 https://github.com/simapple/spider 13、findtrip [13]– 机票爬虫（去哪儿和携程网）。 Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。 https://github.com/fankcoder/findtrip 163spider [14] – 基于requests、MySQLdb、torndb的网易客户端内容爬虫 https://github.com/leyle/163spider doubanspiders[15]– 豆瓣电影、书籍、小组、相册、东西等爬虫集 https://github.com/fanpei91/doubanspiders QQSpider [16]– QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。 https://github.com/LiuXingMing/QQSpider baidu-music-spider [17]– 百度mp3全站爬虫，使用redis支持断点续传。 https://github.com/Shu-Ji/baidu-music-spider tbcrawler[18]– 淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在mongodb。 https://github.com/pakoo/tbcrawler stockholm [19]– 一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。 https://github.com/benitoro/stockholm BaiduyunSpider[20]-百度云盘爬虫。 https://github.com/k1995/BaiduyunSpider Spider[21]-社交数据爬虫。支持微博,知乎,豆瓣。 https://github.com/Qutan/Spider proxy pool[22]-Python爬虫代理IP池(proxy pool)。 https://github.com/jhao104/proxy_pool music-163[23]-爬取网易云音乐所有歌曲的评论。 https://github.com/RitterHou/music-163 jandan_spider[24]-爬取煎蛋妹纸图片。 CnblogsSpider[25]-cnblogs列表页爬虫。 spider_smooc[26]-爬取慕课网视频。 CnkiSpider[27]-中国知网爬虫。 knowsecSpider2[28]-知道创宇爬虫题目。 aiss-spider[29]-爱丝APP图片爬虫。 SinaSpider[30]-动态IP解决新浪的反爬虫机制，快速抓取内容。 csdn-spider[31]-爬取CSDN上的博客文章。 ProxySpider[32]-爬取西刺上的代理IP，并验证代理可用性 作者：一直在水下链接：https://www.jianshu.com/p/39d4b15c05ee來源：简书]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16道Python经典面试题及答案]]></title>
    <url>%2Fyear%2F02%2F26%2F34102%2F</url>
    <content type="text"><![CDATA[随着Python在企业中的应用越来越多，岗位需求越来越大，面试成为了搞定优质职位的快速方式，下面是笔者面试10余家企业总结的面试题，希望对Python从业者有帮助。 1.Python是如何进行内存管理的？ 答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制 一、对象的引用计数机制Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1，一个对象分配一个新名称 2，将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1，使用del语句对对象别名显示的销毁 2，引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 二、垃圾回收 1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 三、内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 2.什么是lambda函数？它有什么好处? 答：lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数 lambda函数：首要用途是指点短小的回调函数 lambda [arguments]:expression a=lambdax,y:x+y a(3,11) 3.Python里面如何实现tuple和list的转换？ 答：直接使用tuple和list函数就行了，type()可以判断对象的类型 4.请写出一段Python代码实现删除一个list里面的重复元素 答：1,使用set函数，set(list) 2，使用字典函数， =[1,2,4,2,4,5,6,5,7,8,9,0] b={} b=b.fromkeys(a) c=list(b.keys()) c 5.编程用sort进行排序，然后从最后一个元素开始判断 a=[1,2,4,2,4,5,7,10,5,5,7,8,9,0,3] a.sort() last=a[-1] for i inrange(len(a)-2,-1,-1): if last==a[i]: del a[i] else:last=a[i] print(a) 6.Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别） 答：赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。 浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数} 深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数} 7.介绍一下except的用法和作用？ 答：try… except… except… [else…] [finally…]执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行如果存在finally语句，最后总是会执行。 8.Python中pass语句的作用是什么？ 答：pass语句不会执行任何操作，一般作为占位符或者创建占位程序，while False: pass 9.介绍一下Python下range()函数的用法？ 答：列出一组数据，经常用在for in range()循环中. 10.如何用Python来进行查询和替换一个文本字符串？ 答：可以使用re模块中的sub()函数或者subn()函数来进行查询和替换，格式： sub(replacement, string[,count=0])（replacement是被替换成的文本，string是需要被替换的文本，count是一个可选参数，指最大被替换的数量） import re p=re.compile(‘blue|white|red’) print(p.sub(‘colour’,’blue socks and red shoes’)) colour socks and colourshoes print(p.sub(‘colour’,’blue socks and red shoes’,count=1)) colour socks and redshoes subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量 11.Python里面match()和search()的区别？ 答：re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。 re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。 print(re.match(‘super’, ‘superstition’).span()) (0, 5) print(re.match(‘super’, ‘insuperable’)) None print(re.search(‘super’, ‘superstition’).span()) (0, 5) print(re.search(‘super’, ‘insuperable’).span()) (2, 7) 12.用Python匹配HTML tag的时候，和有什么区别？ 答：术语叫贪婪匹配( )和非贪婪匹配( )例如: test : test : 13.Python里面如何生成随机数？ 答：random模块随机整数：random.randint(a,b)：返回随机整数x,a&lt;=x&lt;=b random.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。 随机实数：random.random( ):返回0到1之间的浮点数 random.uniform(a,b):返回指定范围内的浮点数。 14.有没有一个工具可以帮助查找python的bug和进行静态的代码分析？ 答：PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告 Pylint是另外一个工具可以进行codingstandard检查 15.如何在一个function里面设置一个全局的变量？ 答：解决方法是在function的开始插入一个global声明： def f(): global x 16.单引号，双引号，三引号的区别 答：单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释 如果要表示Let’s go 这个字符串 单引号：s4 = ‘Let\’s go’ 双引号：s5 = “Let’s go” s6 = ‘I realy like“python”!’ 这就是单引号和双引号都可以表示字符串的原因了作者：地球的外星人君链接：https://zhuanlan.zhihu.com/p/34124369来源：知乎]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法和数据结构 －－ 初等排序]]></title>
    <url>%2Fyear%2F02%2F21%2F19195%2F</url>
    <content type="text"><![CDATA[排序就是将数据按一定顺序重新排列。它是很多算法的基础，可以让数据变得更容易处理。这篇文章会简单地介绍几种排序算法，当然这是初等排序，在效率上会比较差，但实现起来相对容易。 1. 插入排序法插入排序法是一种很容易想到的算法，它的思路与打扑克时排列手牌的方法很相似。 插入排序法的算法如下： insertionSort(A,N) //包含N个元素的0起点数组A for i从１到N-1 v = A[i] j = i - 1 while j &gt;= 0 且 A[j] &gt; v A[j+1] = A[j] j– A[j+1] = v 请编写一个程序，用插入排序法将包含N个元素的数列A按升序排列。为检验算法的执行过程，请输出个计算步骤的数组。 输入 在第１行输入定义数组长度的整数N。在第２行输入N个整数，以空格隔开。 输出 输出总共有N行。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 1000 C #include &lt;stdio.h&gt; /* 按顺序输出数组元素 */ void trace(int A[], int N){ int i; for(i=0;i&lt;N;i++){ if(i&gt;0) printf(&quot; &quot;); /*相邻元素之间输出１个空格 */ printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); } /* 插入排序 */ void insertionSort(int A[], int N){ int j, i, v; for(i=1;i&lt;N;i++){ v = A[i]; j=i-1; while(j&gt;=0 &amp;&amp; A[j]&gt;v){ A[j+1] = A[j]; j--; } A[j+1] = v; trace(A,N); } } int main(){ int N, i, j; int A[100]; scanf(&quot;%d&quot;, &amp;N); for(i=0; i &lt; N; i++) scanf(&quot;%d&quot;, &amp;A[i]); trace(A,N); insertionSort(A,N); return 0; } 2. 冒泡排序法顾名思义，冒泡排序法就是让数组元素像水中的气泡一样逐渐上浮，进而达到排序的目的。下述算法便是利用冒泡排序法将数列排为升序的例子。 bubbleSort(A,N) //包含N个元素的0起点数组A flag = 1 while flag flag = 0 for j从N-1到1 if A[j]&lt;A[j-1] A[j]与A[j-1]交换 flag = 1 请编写一个程序，读取数列A，利用冒泡排序法将其按升序排列并输出。另外请报告冒泡排序法执行元素交换的次数。 输入 在第１行输入定义数组长度的整数N。在第2行输入N个整数，以空格隔开。 输出 总计２行。请在第１行输出排序后的数列。相邻元素以一个空格隔开。第２行输出元素交换的次数。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 100 C++ #include &lt;iostream&gt; using namespace std; //使用flag的冒泡排序法 int bubbleSort(int A[], int N){ int sw = 0; bool flag = 1; for(int i=0; flag; i++){ flag = 0; for(int j= N-1; j&gt;=i+1; j--){ if(A[j] &lt; A[j-1]){ swap(A[j], A[j-1]); flag = 1; sw++; } } } return sw; } int main(){ int A[100], N, sw; cin &gt;&gt; N; for( int i=0; i&lt; N; i++) cin &gt;&gt; A[i]; sw = bubbleSort(A,N); for(int i=0; i &lt; N; i++){ if (i) count &lt;&lt; &quot; &quot;; count &lt;&lt; A[i]; } count &lt;&lt; endl; count &lt;&lt; sw &lt;&lt; endl; return 0; } 3.选择排序法选择排序法是一种非常直观的算法，它会在每个计算步骤中选出一个最小值，进而完成排序。 selectionSort(A,N) for i 从0到N-1 minj = i for j从i到N-1 if A[j] &lt; A[minj] minj = j A[i]与A[min]交换 请编写一个程序，读取数列A，利用选择排序法将其按升序排列并输出。请输出实际运行过程中执行交换操作的次数。 输入 在第１行输入定义数组长度的整数N。在第2行输入N个整数，以空格隔开。 输出 总计２行。请在第１行输出排序后的数列。相邻元素以一个空格隔开。第２行输出元素交换的次数。 限制 1 =&lt; N =&lt; 100 0 =&lt; A的元素 =&lt; 100 C #include &lt;stdio.h&gt; /*选择排序法*/ int selectionSort( int A[], int N){ int i,j, t, sw=0, minj; for(i = 0;i &lt; N-1; i++){ minj = i; for(j = i; j&lt; N; j++) { if(A[j] &lt; A[minj] ) minj = j; } t = A[i]; A[i] = A[minj]; A[minj] = t; if (i != minj) sw++; } return sw; } int main(){ int A[100], N, i, sw; scanf(&quot;%d&quot;, &amp;N); for(i=0; i &lt; N; i++) scanf(&quot;%d&quot;, &amp;A[i]); sw = selectionSort(A,N); for(i = 0; i &lt; N; i++){ if( i &gt; 0) printf(&quot; &quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); printf(&quot;%d&quot;, A[i]); } printf(&quot;\n&quot;); printf(&quot;%d\n&quot;, sw); return 0; } 4. 稳定排序所谓稳定排序，是指当数据中存在２个或２个以上键值相等的元素时，这些元素在排序处理前后顺序不变。 现在我们来给扑克牌排序。我们使用的扑克牌包含S,H,C,D的４种花色以及１，２，…,9，的９个数字，总计３６张。例如红桃８记为“H８”，方块１记为“D1”。 请编写一个程序，分别用冒泡排序法和选择排序法对输入的N张扑克牌进行以数字为基准的升序排列。两种算法需各自遵循下述伪代码的描述。下述数组元素皆为0起点。 bubbleSort(C,N) for i = 0 to N-1 for j = N-1 downto i+1 if C[j].value &lt; C[j-1].value C[j] 与 C[j-1]交换 selestionSort(C, N) for i = 0 to N-1 minj = i for j = i to N-1 if C[j].value &lt; C[minj].value minj = j C[i] 与 C[minj] 交换 另外，请报告各算法对于所给输入是否有稳定输出。 输入 在第１行输入扑克牌的张数N. 第２行输入N张扑克牌的数据。每张牌由代表花色和数字的２个字符组成，相邻扑克牌之间用１个空格隔开。 输出 在第一行按顺序输出经冒泡排序法排序后的扑克牌，相邻扑克牌之间用１个空格隔开。 在第２行输出该输出是否稳定。 在第3行按顺序输出经选择排序法排序后的扑克牌，相邻扑克牌之间用１个空格隔开。 在第4行输出该输出是否稳定。 限制 1 =&lt; N =&lt; 36C++ #include &lt;iostream&gt; using namespace std; struct Card{ char suit, value;}; void bubble(struct Card A[], int N){ for(int i=0; i&lt;N; i++){ for(int j = N-1; j &gt;= i+1; j--){ if(A[j].value &lt; A[j-1].value){ Card t= A[j]; A[j]=A[j-1]; A[j-1]=t; } } } } void selection(struct Card A[], int N){ for(int i=0; i&lt;N;i++){ int minj = i; for(int j=i; j&lt; N; j++){ if(A[j].value &lt; A[minj].value) minj = j; } Card t = A[i]; A[i] = A[minj]; A[minj] = t; } } void print(struct Card A[], int N){ for (int i=0; i&lt;N; i++){ if(i&gt;0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; A[i].suit&lt;&lt; A[i].value; } cout &lt;&lt; endl; } bool isStable(struct Card C1[], struct Card C2[], int N){ for( int i=0; i&lt; N;i++){ if(C1[i].suit != C2[i].suit) return false; } return true; } int main(){ Card C1[100], C2[100]; int N; char ch; cin &gt;&gt; N;&apos; for( int i=0; i&lt; N;i++){ cin &gt;&gt; C1[i[.suit &gt;&gt; C1[i].value; } for(int i=0; i&lt;N; i++) C2[i] = C1[i]; bubble(C1,N); selection(C2, N); print(C1,N); cout&lt;&lt; &quot;Stable&quot; &lt;&lt; endl; print(C2, N); if( isStable(C1,C2,N){ cout&lt;&lt; &quot;Stable&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;not stable&quot; &lt;&lt; endl; } return 0; } 5. 希尔排序法我们在插入排序法的基础上进一步发挥，将包含ｎ个整数的数列A通过下列程序进行升序排列。 insertionSort(A,n,g) for i = g to n-1 v = A[i] j = i - g while j &gt;= 0 &amp;&amp; A[j] &gt; v A[j+g] = A[j] j = j - g cnt ++ A[j+g] = v shellSort(A,n) cnt = 0 m = ? G[] = {?,?,?,?,…,?} for i = 0 to m-1 insertionSort(A, n, G[i]) insertionSort(A,n,g)是以间隔为g的元素为对象进行的插入排序。shellSort(A,n)则是insertionSort(A,n,g)的循环，并在每轮循环后逐渐缩小g的范围。这种排序方法称为希尔排序法。 C++ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; using namespace std; long long cnt; int l; int A[1000000]; int n; vector&lt;int&gt; G; //指定了间隔g的插入排序 void insertionSort(int A[], int n, int g){ for( int i = g; i&lt; n; i++){ int v = A[i]; int j = i - g; while (j &gt;= 0 &amp;&amp; A[j] &gt; v){ A[j+g] = A[j]; j -= g; cnt++; } A[j+g] = v; } } void shellSort( int A[], int n){ //生成数列 G={1,4,13,40,121,364, 1093,...} for (int h=1; ; ){ if(h &gt; n) break; G.push_back(h); h = 3*h + 1; } for ( int i = G.size()-1; i&gt;= 0; i--){ //按逆序指定G[i] = g insertionSort(A, n, G[i]); } } int main(){ cin &gt;&gt; n; //使用速度更快的scanf函数进行输入 for ( int i=0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]); cnt = 0; shellSort(A,n); cout &lt;&lt; G.size() &lt;&lt; endl; for( int i= G.size() - 1; i &gt;= 0; i--){ printf(&quot;%d&quot;, G[i]); if(i) printf(&quot; &quot;); } printf(&quot;\n&quot;); printf(&quot;%d\n&quot;, cnt); for ( int i = 0; i &lt; n; i++) printf(&quot;%d\n&quot;, A[i]); return 0; }]]></content>
      <categories>
        <category>Algorithm and Data Structure</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 Socket]]></title>
    <url>%2Fyear%2F02%2F13%2F858%2F</url>
    <content type="text"><![CDATA[1. Socket 基础 Socket原指“孔”或“插座”，它最初作为BSD UNIX的进程通信机制，通常被称作“套接字”。当然，如今Socket已经是Windows和Mac等其他操作系统所共同遵守的网络编程标准，用于描述IP地址和端口，是一个通信连的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。Internet上的主机一般运行了多个服务软件，同时提供几种服务，每种服务都打开一个Socket，并绑定到一个端口上，不用的端口对应不同的服务。 在操作系统结构上，Socket为应用程序屏蔽了TCP/IP网络传输层及以下的网络细节，如图所示。Socket为操作系统的用户空间提供网络抽象，开发者编写的网络程序都会直接或间接地用到Socket抽象。通过Socket抽象可以控制传输层协议TCP和UDP,甚至包括部分网络层协议，例如IP和ICMP。Socket使用IP地址＋端口＋协议的三元组唯一标识一个通信链路。服务器端的一个通信链路可以对应于多个客户端，比如一个Web服务器端的80端口可以同时服务于大量的客户端。 2. 实战演练: Socket TCP 原语 用Socket进行网络开发需了解服务器和客户端的Socket原语，每个原语在不同的高级语言中都有相应的实现方式。TCP的Socket原语如图所示，所有基于TCP的Socket通信都遵循如图所示的流程。下面解释每个原语的含义。socket(): 建立Socket对象。Socket是以类似文件系统的文件系统【打开、读写、关闭】的模式设计的，socket()原语相当于“打开”。socket()原语的参数通常包括使用的传输层协议类型、网络层类型等。 bind(): 绑定。在参数中需要传入要绑定的IP地址和端口。IP地址必须是主机上的一个可用的地址（除了0.0.0.0指定绑定所有的本机IP）。端口必须是一个该Socket协议未被占用的端口，比如当一个主机上的两个程序试图同时绑定到80端口时，只有一个程序能够成功。服务器端程序在listen()之前必须进行bind()操作,而客户端程序如果在connect()原语之前没有调用bind()，则系统会自动为该Socket分配一个未被占用的地址和端口。 技巧: 当主机上存在多个IP时，绑定地址0.0.0.0可以监听所有这些可用的IP。 listen():监听。只在服务器端有用，告诉操作系统开始监听之前绑定的IP地址和端口，可以下参数中指定允许排队的最大连接数量。 connect():在客户端连接服务器。参数中需要指定服务器的地址和端口。调用connect()可能有两种结果，即与服务器端完成TCP３次握手并建立连接或者连接服务器失败。 accept():接受连接。只在服务器端有用，从监听到的连接中取出一个，并将其包装成一个新的Socket对象。这个新的Socket对象可被用于和相应的客户端进行通信。完成accept()标志着Socket已经完成TCP链路建立阶段的3次握手。如果当前没有客户端连接请求，则accept()调用会阻塞等待。 send():发送数据。服务器端和客户端均可调用send()向对方发送数据，在sendI)的参数中传入要发送的数据，通过send()的返回值判断数据是否发送成功。 recv():接收数据。服务器端和客户端均可调用recv()从对方接收数据。如果Socket中没有消息可以读取，则在默认情况下recv()调用会被阻塞直到消息到达；开发者也可以将Socket()设置为非阻塞模式，使recv()以失败形式返回。 close():关闭连接。通信中的任何一方可以调用close()发起关闭连接请求，另一方收到后也可调用close()关闭连接。 【示例】下面通过Python代码演示Socket编程方法，TCP服务器端的代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socketimport datetime HOST=’0.0.0.0’PORT=3434 #AF_INET说明使用IPV4地址， SOCK_STREAM指明TCPs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((HOST,PORT))s.listen(1) while True: conn,addr = s.accept() print ‘Client %s connected!’ % str(addr) dt = datetime.datetime.now() message = “Current time is “ + str(dt) conn.send(Sent: “, message conn.close()包socket封装了所有python的原生Socket操作，代码中通过socket(),bind(),listen()的一系列调用实现了对指定端口的监听，通过accept()接受客户端的连接，当有客户端连接成功后将当前系统时间发送给客户端，并马上关闭连接。因为代码主体处于while循环中，所以程序将不断监听并一直运行。 与该服务器端的代码相对应的客户端代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘127.0.0.1’PORT = 3434 #AF_INET说明使用IPV4地址， SOCK_STREAM指明TCP协议 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) print ‘Connect %s:%d OK!’ % (HOST, PORT) data = s.recv(1024) #接受数据，最大长度为1024 print ‘Received: ‘, data s.close()客户端通过connect()调用、连接服务器，连接成功后接收从服务器发来的数据，然后关闭连接、退出程序。 注意：客户端的Socket端口号由系统自动分配。 3.Socket UDP原语UDP相对于TCP在传输层提供更少的控制，没有建立连接、断开连接等概念，所以基于UDP的Socket通信过程也比TCP稍微简单。在UDP中可以直接指定IP:Port进行数据收发。UDP Socket可以复用TCP中的socket()和bind()原语，除此之外，UDP属于自己的Socket原语如下。 recvfrom():从绑定的地址接收数据。 sendto():向指定的地址发送数据，在调用的参数中应该传入通信对端的地址和端口。 【示例】UDP的python服务器端的代码示例如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘0.0.0.0’PORT = 3434 #AF_INET说明使用IPV4地址， SOCK_DGRAM指明UDPs = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)s.bind() while True(): data, addr = s.recvgrom(1024) print ‘Received: %s’ % (data, str(addr)) s.close()代码通过socket()和bind()调用绑定了本地所有地址的3434端口，通过socket()中的SOCKET_DGRAM指定Socket使用UDP, 在一个循环中不断地接收数据并打印。相应的UDP客户端python代码如下： #!/usr/bin/env python #-- coding: utf-8 -- import socket HOST = ‘127.0.0.1’PORT = 3434 #AF_INET说明使用IPV4地址，socket.SOCK_DGRAM指明UDPs = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) data = “Hello UDP!”s.sendto(data, (HOST, PORT))print “Sent: %s to %s:%d” % (data, HOST, PORT) s.close()]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vultr VPS上搭建Shadowsocks]]></title>
    <url>%2Fyear%2F02%2F07%2F57013%2F</url>
    <content type="text"><![CDATA[作为一个离开Google就没法生活的人，之前也尝试了很多方法。这次自己搭建vpn,也折腾了不少，值得好好记录一下。废话少说，直接进入正题。 1.VPS的选择 可选择的VPS有很多，国内有阿里云、腾讯云，不过随着国内管控越来越严，在国内厂商的VPS上搭建VPN不是一个好的选择(你懂得)。知乎上有个相关话题,需要的可以参考一下。我选择Vultr是因为它便宜，在这里说我也不怕嘲笑，我还是个穷学生，经济问题还是首先要考虑的。可选择的套餐很多，5 $/mon还可以接受。 进入官网后注册登录后还要先充值10，当时我想先充0.01得了，结果人家不傻，最低要10$，也算了，为了我的Google,花点钱也可以学点东西。选择好位置、价格后，其他的默认就行了，然后就可以部署了。 提示：系统最好选择centos 6，方便部署 2.在VPS上部署Shadowsocks首先先登录到VPS上，我系统是Ubuntu 16.04 LTS,直接ssh root@your vps ipaddress ipaddress可以在这里看密码是系统默认生成的，如果需要修改密码，可以参考这个官方教程。 2.1下面开始进入重点，部署Shadowsocks服务端.这里使用 teddysun 的一键安装脚本。 依次输入下面三条命令 wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2>&1 | tee shadowsocks.log 最后一步输完，你应该会看到下图中内容──是要你为 Shadowsocks 服务设置一个个人密码。 设置 ss 密码输好回车后会让你选择一个端口，输入 1-65535 间的数字都行。 设置 ss 端口 遵照上图指示，按任意键开始部署 Shadowsocks。这时你什么都不用做，只需要静静地等它运行完就好。结束后就会看到你所部署的 Shadowsocks 的配置信息。 ss 配置信息记住黄框中的内容，也就是服务器 IP、服务器端口、你设的密码和加密方式。 2.2 TCP Fast Open实际上只要具备上述四个信息，你就可以在自己的任意设备上进行登录使用了。但是为了更好的连接速度，你还需要多做几步。 首先是打开 TCP Fast Open，输入以下命令，意为用 nano 这个编辑器打开一个文件。 nano /etc/rc.local 你的「终端」会刷新一下，出现下图。 别慌张，它就是个文本编辑器。用方向键把光标移到最末端，粘贴下面这一行内容，然后按 Ctrl + X 退出。 echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 输入“Y”并回车确认退出。 然后依法炮制，输入：nano /etc/sysctl.conf 在文末加上下面的内容，保存退出。 net.ipv4.tcp_fastopen = 3 打开一个 Shadowsocks 配置文件。 nano /etc/shadowsocks.json 把其中 “fast_open” 一项的 false 替换成 true。 “fast_open”:true 如果你希望添加多用户的话，可以将 “password” 字段如下图修改。其中，”22345”:”password1”意为该用户使用 22345 端口、以“password1”为密码连接登录 Shadowsocks。 保存退出。最后，输入以下命令重启 Shadowsocks。 /etc/init.d/shadowsocks restart 2.3 安装 Shadowsocks 客户端客户端安装就简单很多了，Android、Win、Mac这里就不再多述了。Linux客户端配置还是很麻烦的，改天再单独写个教程。 3.开启锐速完成上述步骤后，使用过程中可能会发现连接速度有时不太稳定。这就是「锐速」发挥功能的时候了。 3.1 什么是锐速锐速 ServerSpeeder 是一个 TCP 加速软件，对 Shadowsocks 客户端和服务器端间的传输速度有显著提升。而且，不同于 FinalSpeed 或 Kcptun 等需要客户端的工具，「锐速」的一大优势是只需要在服务器端单边部署就行了。换句话说，你不需要再安装另外一个应用。另外，「锐速」虽然已经停止注册和安装了，不过网上还是有不少「破解版」可用。 3.2 部署锐速首先需要用 SSH 登录 VPS。 ssh root@your vps ipaddress 依然使用一键安装脚本，输入以下命令。 wget -N –no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh && bash serverspeeder-all.sh 安装需要一段时间，等待一会。如果出现下图内容，请按提示输入数字。另外，若运行中碰到提示说需要更换内核的话，请参考此文更换之。 安装完成后，输入以下命令打开配置文件。 nano /serverspeeder/etc/config 将 advinacc 的 0 改为 1，保存并退出。 退出「终端」程序。至此，整个搭建过程就大功告成了！接下来，尽情地享受起飞的速度吧😄 需要帮助的话直接联系我。]]></content>
      <categories>
        <category>Geeker</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>vps</tag>
        <tag>ss</tag>
      </tags>
  </entry>
</search>
