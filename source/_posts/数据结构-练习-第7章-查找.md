---
title: 数据结构--练习 第7章 查找
categories: Algorithm and Data Structure
abbrlink: 2101
date: 2018-05-25 20:24:43
tags:
---
* * *
<!--more-->
1．选择题

（1）对n个元素的表做顺序查找时，若查找每个元素的概率相同，则平均查找长度为（   ）。

A．(n-1)/2       B． n/2        C．(n+1)/2        D．n 

答案：C

解释：总查找次数N=1+2+3+…+n=n(n+1)/2，则平均查找长度为N/n=(n+1)/2。

（2）适用于折半查找的表的存储方式及元素排列要求为（   ）。

  A．链接方式存储，元素无序            B．链接方式存储，元素有序

C．顺序方式存储，元素无序            D．顺序方式存储，元素有序

答案：D

解释：折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。

（3）如果要求一个线性表既能较快的查找，又能适应动态变化的要求，最好采用(    )查找法。

A．顺序查找 B．折半查找

C．分块查找 D．哈希查找

答案：C

解释：分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。

（4）折半查找有序表（4，6，10，12，20，30，50，70，88，100）。若查找表中元素58，则它将依次与表中（   ）比较大小，查找结果是失败。

A．20，70，30，50                    B．30，88，70，50

C．20，50                            D．30，88，50

答案：A

解释：表中共10个元素，第一次取ë(1+10)/2û=5，与第五个元素20比较，58大于20，再取ë(6+10)/2û=8，与第八个元素70比较，依次类推再与30、50比较，最终查找失败。

（5）对22个记录的有序表作折半查找，当查找失败时，至少需要比较（   ）次关键字。

A．3            B．4          C．5           D．6

答案：B

解释：22个记录的有序表，其折半查找的判定树深度为 ëlog222û + 1=5，且该判定树不是满二叉树，即查找失败时至多比较5次，至少比较4次。

（6）折半搜索与二叉排序树的时间性能（   ）。

  A．相同                              B．完全不同        

C．有时不相同                        D．数量级都是O(log2n)

答案：C

（7）分别以下列序列构造二叉排序树，与用其它三个序列所构造的结果不同的是（   ）。 

A．（100，80， 90， 60， 120，110，130）

B．（100，120，110，130，80， 60， 90）

C．（100，60， 80， 90， 120，110，130）

D．(100，80， 60， 90， 120，130，110)

答案：C

解释：A、B、C、D四个选项构造二叉排序树都以100为根，易知A、B、D三个序列中第一个比100小的关键字为80，即100的左孩子为80，而C选项中100的左孩子为60，故选C。

（8）在平衡二叉树中插入一个结点后造成了不平衡，设最低的不平衡结点为A，并已知A的左孩子的平衡因子为0右孩子的平衡因子为1，则应作（   ）型调整以使其平衡。

A．LL           B．LR          C．RL          D．RR

答案：C

（9）下列关于m阶B-树的说法错误的是（   ）。

A．根结点至多有m棵子树     

B．所有叶子都在同一层次上

C．非叶结点至少有m/2 (m为偶数)或m/2+1（m为奇数）棵子树  

D．根结点中的数据是有序的

答案：D

（10）下面关于B-和B+树的叙述中，不正确的是（   ）。 

A．B-树和B+树都是平衡的多叉树       B．B-树和B+树都可用于文件的索引结构

C．B-树和B+树都能有效地支持顺序检索 D．B-树和B+树都能有效地支持随机检索

答案：C

（11）m阶B-树是一棵（   ）。

A．m叉排序树                        B．m叉平衡排序树  

C．m-1叉平衡排序树                  D．m+1叉平衡排序树

答案：B

（12）下面关于哈希查找的说法，正确的是（   ）。         

A．哈希函数构造的越复杂越好，因为这样随机性好，冲突小      

B．除留余数法是所有哈希函数中最好的   

C．不存在特别好与坏的哈希函数，要视情况而定

D．哈希表的平均查找长度有时也和记录总数有关

答案：C

（13）下面关于哈希查找的说法，不正确的是（   ）。              

  A．采用链地址法处理冲突时，查找一个元素的时间是相同的

  B．采用链地址法处理冲突时，若插入规定总是在链首，则插入任一个元素的时间是相同的

  C．用链地址法处理冲突，不会引起二次聚集现象

  D．用链地址法处理冲突，适合表长不确定的情况

答案：A

解释：在同义词构成的单链表中，查找该单链表表中不同元素，所消耗的时间不同。

（14）设哈希表长为14，哈希函数是H(key)=key%11，表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的元素加到表中，用二次探测法解决冲突，则放入的位置是（   ）。

  A．8              B．3              C．5             D．9

答案：D

解释：关键字15放入位置4，关键字38放入位置5，关键字61放入位置6，关键字84放入位置7，再添加关键字49，计算得到地址为5，冲突，用二次探测法解决冲突得到新地址为6，仍冲突，再用用二次探测法解决冲突，得到新地址为4，仍冲突，再用用二次探测法解决冲突，得到新地址为9，不冲突，即将关键字49放入位置9。

（15）采用线性探测法处理冲突，可能要探测多个位置，在查找成功的情况下，所探测的这些位置上的关键字 (    )。

A．不一定都是同义词                  B．一定都是同义词       

C．一定都不是同义词                  D．都相同

答案：A

解释：所探测的这些关键字可能是在处理其它关键字冲突过程中放入该位置的。

2．应用题

[参考这里](https://blog.csdn.net/m0_37243410/article/details/79008608)
3．算法设计题

（1）试写出折半查找的递归算法。

 [算法描述]
```sh
int  BinSrch（rectype r[ ]，int  k，low，high）

//在长为n的有序表中查找关键字k，若查找成功，返回k所在位置，查找失败返回0。

{if（low≤high）  //low和high分别是有序表的下界和上界

  {mid=（low+high）/2；

   if（r[mid].key==k）return  （mid）；

   else if（r[mid].key>k）return  （BinSrch（r,k，mid+1，high））;

        else return  （BinSrch（r,k，low，mid-1））;

   }

 else  return  （0）；//查找失败。

}//算法结束
```
（2）试写一个判别给定二叉树是否为二叉排序树的算法。

[题目分析] 根据二叉排序树中序遍历所得结点值为增序的性质，在遍历中将当前遍历结点与其前驱结点值比较，即可得出结论，为此设全局指针变量pre（初值为null）和全局变量flag，初值为true。若非二叉排序树，则置flag为false。

[算法描述]
```sh
#define true 1

#define false 0

typedef struct node

{datatype data; struct node *lchild,*rchild;} *BTree;

void  JudgeBST（BTree T,int  flag）

// 判断二叉树是否是二叉排序树，本算法结束后，在调用程序中由flag得出结论。

{ if（T!=null && flag）

     { Judgebst（T->lchild,flag）；// 中序遍历左子树

        if（pre==null）pre=T；// 中序遍历的第一个结点不必判断

        else  if（pre->data<T->data）pre=T；//前驱指针指向当前结点

                else{flag=flase；}   //不是完全二叉树

        Judgebst （T->rchild,flag）；// 中序遍历右子树

}//JudgeBST算法结束

``` 

（3）已知二叉排序树采用二叉链表存储结构，根结点的指针为T，链结点的结构为（lchild,data,rchild），其中lchild，rchild分别指向该结点左、右孩子的指针，data域存放结点的数据信息。请写出递归算法，从小到大输出二叉排序树中所有数据值>=x的结点的数据。要求先找到第一个满足条件的结点后，再依次输出其他满足条件的结点。

[题目分析]本题算法之一是如上题一样，中序遍历二叉树，在“访问根结点”处判断结点值是否≥x，如是则输出，并记住第一个≥x值结点的指针。这里给出另一个算法，利用二叉排序树的性质，如果根结点的值>=x,则除左分枝中可能有<x的结点外都应输出。所以从根结点开始查找，找到结点值<x的结点后，将其与双亲断开输出整棵二叉排序树。如果根结点的值<x,则沿右子树查找第一个≥x的结点，找到后，与上面同样处理。
```sh
   void  Print（BSTree  t）

       // 中序输出以t为根的二叉排序树的结点

    {if（t）{Print（t->lchild）；

             Cout<<t-data；

             Print（t->rchild）；

            }

    }

   void  PrintAllx(BSTree bst，datatype x）

       //在二叉排序树bst中，查找值≥x的结点并输出

{p=bst；

if（p）

      {while（p && p->data<x）p=p->rchild；//沿右分枝找第一个值≥x的结点

       bst=p; //bst所指结点是值≥x的结点的树的根

       if（p）

         {f=p; p=p->lchild ；//找第一个值<x的结点

          while（p && p->data≥x）//沿左分枝向下，找第一个值<x的结点

            {f=p；p=p->lchild ；} //f是p的双亲结点的指针，指向第一个值≥x的结点

             if(p) f->lchild=null; //双亲与找到的第一个值<x的结点断开

Print(bst)；//输出以bst为根的子树

            }//while

         }//内层if（p）

       }//第一层if（p）

 }//PrintAllx
```
 

（4）已知二叉树T的结点形式为（lling,data,count,rlink），在树中查找值为X的结点，若找到，则记数（count）加1，否则，作为一个新结点插入树中，插入后仍为二叉排序树，写出其非递归算法。

[算法描述]
```sh
void SearchBST(BiTree &T,int target){

BiTree s,q,f;  //以数据值target,新建结点s

s=new BiTNode;

s->data.x=target;

s->data.count=0;

s->lchild=s->rchild=NULL;


if(!T){

T=s;

return ;

}   //如果该树为空则跳出该函数

f=NULL;

q=T;

while (q){

if (q->data.x==target){

q->data.count++;

return ;

}  //如果找到该值则计数加一

f=q;

if (q->data.x>target)   //如果查找值比目标值大，则为该树左孩子

q=q->lchild;

else //否则为右孩子

q=q->rchild;

}  //将新结点插入树中

if(f->data.x>target)

f->lchild=s;

else

f->rchild=s;

}
```
（5）假设一棵平衡二叉树的每个结点都表明了平衡因子b，试设计一个算法，求平衡二叉树的高度。

[题目分析] 因为二叉树各结点已标明了平衡因子b，故从根结点开始记树的层次。根结点的层次为1，每下一层，层次加1，直到层数最大的叶子结点，这就是平衡二叉树的高度。当结点的平衡因子b为0时，任选左右一分枝向下查找，若b不为0，则沿左（当b=1时）或右（当b=-1时）向下查找。

[算法描述]
```sh
    int   Height（BSTree t）

      // 求平衡二叉树t的高度

      {level=0；p=t；

       while（p）

        {level++； // 树的高度增1

if（p->bf<0）p=p->rchild；//bf=-1 沿右分枝向下

//bf是平衡因子，是二叉树t结点的一个域，因篇幅所限，没有写出其存储定义

         else p=p->lchild；        //bf>=0 沿左分枝向下

}//while

       return  （level）；//平衡二叉树的高度

} //算法结束
```
 

（6）分别写出在散列表中插入和删除关键字为K的一个记录的算法，设散列函数为H，解决冲突的方法为链地址法。

[算法描述]
```sh
bool insert(){

int data;

cin>>data;

int ant=hash(data);

LinkList p=HT[ant];   //初始化散列表

while (p->next){

if(p->next->data==data)

return false;   

p=p->next;

}   //找到插入位置

LinkList s;

s=new LNode;

s->data=data;

s->next=p->next;

p->next=s;  //插入该结点

return true;

}

 

bool deletes(){

int data;

cin>>data;

int ant=hash(data);

LinkList p=HT[ant];  //初始化散列表

while (p->next){

if(p->next->data==data){

LinkList s=p->next;

p->next=s->next;

delete s;  //删除该结点

return true;

}  //找到删除位置

p=p->next； //遍历下一个结点

}

return false;

}
```